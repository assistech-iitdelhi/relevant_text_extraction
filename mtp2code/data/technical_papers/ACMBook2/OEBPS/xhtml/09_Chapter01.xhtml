<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Sparse Fourier Transform: Theory and Practice</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="../styles/page-template.xpgt"/>
</head>
<body>
<p class="chno"><a id="page_1"/><b>1</b></p>
<p class="chtitle"><b>Introduction</b></p>
<p class="noindent">The Fourier transform is one of the most important and widely used computational tasks. It is a foundational tool commonly used to analyze the spectral representation of signals. Its applications include audio/video processing, radar and GPS systems, wireless communications, medical imaging and spectroscopy, the processing of seismic data, and many other tasks [Bahskarna and Konstantinides 1995, Chan and Koo 2008, Heiskala and Terry 2001, Nishimura 2010, Van Nee and Coenen 1991, Yilmaz 2008]. Hence, faster algorithms for computing the Fourier transform can benefit a wide range of applications. The fastest algorithm to compute the Fourier transform today is the Fast Fourier Transform (FFT) algorithm [Cooley and Tukey 1965]. Invented in 1965 by Cooley and Tukey, the FFT computes the Fourier transform of a signal of size <i>n</i> in <i>O</i>(<i>n</i> log <i>n</i>) time. This near-linear time of the FFT made it one of the most influential algorithms in recent history [Cipra 2000]. However, the emergence of big data problems, in which the processed datasets can exceed terabytes [Schadt et al. 2010], has rendered the FFT&#8217;s runtime too slow. Furthermore, in many domains (e.g., medical imaging, computational photography), data acquisition is costly or cumbersome, and hence one may be unable to collect enough measurements to compute the FFT. These scenarios motivate the need for sublinear time algorithms that compute the Fourier transform faster than the FFT algorithm and use only a subset of the input data required by the FFT.</p>
<p class="indent">The key insight to enable sublinear Fourier transform algorithms is to exploit the inherit <i>sparsity</i> of natural signals. In many applications, most of the Fourier coefficients of the signal are small or equal to zero, i.e., the output of the Fourier transform is <i>sparse</i>. For such signals, one does not need to compute the entire output of the Fourier transform; it is sufficient to only compute the large frequency coefficients. Fourier sparsity is in fact very common as it appears in audio/video, medical imaging, computational learning theory, analysis of Boolean functions, similarity search in databases, spectrum sensing, datacenter monitoring, etc. [Agrawal et al. 1993, Chandrakasan et al. 1996, Kahn et al. 1988, Lin et al. 2011, Lustig et al. 2008, Mueen et al. 2010].</p>
<p class="indent"><a id="page_2"/>This book pursues the above insight in the context of both algorithms and systems in order to answer the following two core questions.</p>
<p class="quotet"><i>How can we leverage sparsity to design faster Fourier transform algorithms?</i></p>
<p class="noindentt">and</p>
<p class="quotet"><i>How do we build software and hardware systems that adapt our algorithms to various application domains in order to deliver practical gains?</i></p>
<p class="indentt">In this book, we will answer the above questions by presenting the Sparse Fourier Transform algorithms: a family of sublinear algorithms for computing the Fourier transform of frequency-sparse signals faster than FFT and using a small subset of the input samples. The book also describes architectures for leveraging sparsity to build practical systems that solve key problems in wireless networks, mobile systems, computer graphics, medical imaging, biochemistry, and digital circuits.</p>
<p class="indent">The book is divided into two parts: theoretical algorithms and systems. The theoretical part introduces the algorithmic foundations of the Sparse Fourier Transform which encompass two main axes.</p>
<p class="hang"><b>Optimizing the Runtime Complexity.</b> The book presents Sparse Fourier Transform algorithms with the lowest runtime complexity known to date. For exactly sparse signals, we present an algorithm that runs in <i>O</i>(<i>k</i> log <i>n</i>) time where <i>k</i> is the number of large frequency coefficients (i.e., sparsity) and <i>n</i> is the signal size. This algorithm is optimal if the FFT algorithm is optimal. For approximately sparse signals, which we will formally define in <a href="#ch1_1_1">Section 1.1.1</a>, we present an algorithm that runs in <i>O</i>(<i>k</i> log <i>n</i> log (<i>n</i>/<i>k</i>)) time which is log <i>n</i> factor away from optimal. Both algorithms improve over FFT for any sparsity <i>k</i> = <i>o</i>(<i>n</i>) and have small &#8220;Big-Oh&#8221; constants. As a result, they are often faster than FFT in practice and run quickly on very large data sets.</p>
<p class="hang"><b>Optimizing the Sampling Complexity.</b> The book presents Sparse Fourier Transform algorithms with the <i>optimal</i> sampling complexity for average case inputs, i.e., these algorithms use the minimum number of input data samples that would produce a correct answer. Hence, they reduce the acquisition cost, bandwidth, and I/O overhead needed to collect, transfer, and store the data. Specifically, these algorithms require only <i>O</i>(<i>k</i>) samples for exactly sparse signals and <i>O</i>(<i>k</i> log <i>n</i>) samples for approximately sparse signals while keeping the same runtime complexity of the aforementioned worst case algorithms. Furthermore, the algorithms naturally extend to multi-dimensional Sparse Fourier Transforms, without incurring much overhead.</p>
<p class="indentt"><a id="page_3"/>The simplicity and practicality of the Sparse Fourier Transform algorithms enabled the design of six new systems that address major challenges in the areas of wireless networks and mobile systems, computer graphics, medical imaging, biochemistry, and digital circuits. <a href="#tab1_1">Table 1.1</a> summarizes the systems developed using the Sparse Fourier Transform and the innovation in each system</p>
<p class="indent">Leveraging the Sparse Fourier Transform to build practical systems, however, is not always straightforward. The Sparse Fourier Transform is a framework of algorithms and techniques for analyzing sparse signals. It inherently depends on the sparsity of the signal which changes from one application to another. Thus, incorporating domain knowledge from each application allows us to deliver much more significant gains. First, different applications exhibit different levels and structure of sparsity. For example, in wireless networks, occupied frequencies in the wireless spectrum are not randomly distributed. They are instead clustered based on transmission regulations set by the FCC. Hence, incorporating the structure of the sparsity into the algorithm and system is essential for achieving good performance gains. In addition, in some applications such as medical imaging, the sparsity of the signal is not apparent, which requires developing methods to sparsify the signal before being able to use the Sparse Fourier Transform. In other applications, sparsity appears only in part of the system and thus we have to redesign the entire system in order to propagate the gains of the Sparse Fourier Transform to other stages and improve the overall system performance. Hence, adapting the Sparse Fourier Transform into practical applications requires a deep understanding of the application domain and customizing the algorithms to become more in-sync with the system requirements which we will explore throughout this book.</p>
<p class="indent">The next two sections provide an overview of the theoretical algorithms and the software and hardware systems presented in this book.</p>
<p class="h1"><b><a id="ch1_1"/><span class="big">1.1</span>&#160;&#160;&#160;&#160;Sparse Fourier Transform Algorithms</b></p>
<p class="noindent">The existence of Fourier transform algorithms faster than FFT is one of the central questions in the theory of algorithms. The past two decades have witnessed significant advances in sublinear Fourier algorithms for sparse signals. The first such algorithm (for the Hadamard transform) appeared in Kushilevitz and Mansour [1991] (building on Goldreich and Levin [1989]). Since then, several sublinear algorithms for complex Fourier inputs have been discovered [Akavia et al. 2003, Akavia 2010, Gilbert et al. 2002, Gilbert et al. 2005a, Iwen 2010b, Mansour 1992]. The main value of these algorithms is that they outperform FFT&#8217;s runtime for sparse signals. For very sparse signals, the fastest algorithm is due to Gilbert et al. [2005a] and has <i>O</i>(<i>k</i> log<sup><i>c</i></sup>(<i>n</i>) log(<i>n</i>/<i>k</i>)) runtime, for some <i>c</i> &#62; 2. This algorithm outperforms FFT for any <i>k</i> smaller than &#920;(<i>n</i>/ log<i><sup>a</sup> n</i>) for some <i>a</i> &#62; 1.</p>
<p class="tcaption"><a id="page_4"/><a id="tab1_1"/><b>Table 1.1</b> Practical systems developed using the Sparse Fourier Transform</p>
<p class="image"><img src="../images/tab1_1.png" alt="image"/></p>
<p class="indent"><a id="page_5"/>Despite this impressive progress, the prior work suffers from two main limitations. First, none of the existing algorithms improves over FFT&#8217;s runtime for the whole range of sparse signals, i.e., <i>k</i> = <i>o</i>(<i>n</i>). Second, the aforementioned algorithms are quite complex, and suffer from large &#8220;Big-Oh&#8221; constants that lead to long runtime in practice. For example, an implementation of the algorithm in Gilbert et al. [2005a] can only outperform FFT for extremely sparse signals where <i>k/n</i> &#8804; 3.2 &#215; 10<sup>&#8722;5</sup> [Iwen et al. 2007]. The algorithms in Gilbert et al. [2002] and Iwen [2010b] require an even sparser signal (i.e., larger <i>n</i> and smaller <i>k</i>). As a result, it has been difficult to incorporate those algorithms into practical systems.</p>
<p class="indent">In this section, we give an overview of our Sparse Fourier Transform algorithms, which address the above limitations of prior work. We start by formalizing the problem. We then describe the algorithmic framework underlying all of our Sparse Fourier Transform algorithms. Once we establish this framework, we describe the different techniques that can be used at each step of a Sparse Fourier Transform algorithm. We finally present the various algorithms that result from using these techniques.</p>
<p class="h2"><a id="ch1_1_1"/><b><span class="big1">1.1.1</span>&#160;&#160;&#160;&#160;Problem Statement</b></p>
<p class="noindent">Consider a signal <b>x</b> of size <i>n</i> whose discrete Fourier transform is <b>x&#770;</b> defined by:</p>
<p class="eqn"><a id="eq1_1"/><img src="../images/eq1_1.png" alt="image"/></p>
<p class="noindent"><b>x&#770;</b> is exactly <i>k</i>-sparse if it has exactly <i>k</i> non-zero frequency coefficients while the remaining <i>n</i> &#8722; <i>k</i> coefficients are zero. In this case, the goal of the Sparse Fourier Transform is to exactly recover <i>x&#770;</i> by finding the frequency positions <i>f</i> and values <b>x&#770;</b>(<i>f</i>) of the <i>k</i> non-zero coefficients. For general signals, the Sparse Fourier Transform computes a <i>k-sparse approximation</i> <b>x&#770;</b>&#8242; of <i>x&#770;</i>. The best <i>k-sparse approximation</i> of <i>x&#770;</i> can be obtained by setting all but the largest <i>k</i> coefficients of <i>x&#770;</i> to 0. The goal is to compute an approximation <b>x&#770;&#8242;</b> in which the error in approximating <i>x&#770;</i> is bounded by the error on the best <i>k-sparse approximation</i>. Formally, <i>x&#770;</i> has to satisfy the following &#8467;<sub>2</sub>/&#8467;<sub>2</sub> <i>guarantee</i>:</p>
<p class="eqn"><a id="eq1_2"/><img src="../images/eq1_2.png" alt="image"/></p>
<p class="noindent">where <i>C</i> is some approximation factor and the minimization is over exactly <i>k</i>-sparse signals.</p>
<p class="indent"><a id="page_6"/>In the remainder of this section, we will describe the algorithmic framework and techniques in terms of exactly sparse signals. However, the full details and extensions to the general case of approximately sparse signals can be found in <a href="12_Chapter03.xhtml">Chapters 3</a>, <a href="13_Chapter04.xhtml">4</a>, and <a href="14_Chapter05.xhtml">5</a>.</p>
<p class="h2"><a id="ch1_1_2"/><b><span class="big1">1.1.2</span>&#160;&#160;&#160;&#160;Algorithmic Framework</b></p>
<p class="noindent">The Sparse Fourier Transform has three main components: <i>Frequency Bucketization, Frequency Estimation</i>, and <i>Collision Resolution</i>.</p>
<p class="h3"><a id="ch1_1_2_1"/><b><span class="big2">1.1.2.1</span>&#160;&#160;&#160;&#160;Frequency Bucketization</b></p>
<p class="noindent">The Sparse Fourier Transform starts by hashing the frequency coefficients of <i>x&#770;</i> into buckets such that the value of the bucket is the sum of the values of the frequency coefficients that hash into the bucket. Since <b>x&#770;</b> is sparse, many buckets will be empty and can be simply discarded. The algorithm then focuses on the non-empty buckets and computes the positions and values of the large frequency coefficients in those buckets in what we call the frequency estimation step.</p>
<p class="indent">The process of frequency bucketization is achieved through the use of filters. A filter suppresses and zeroes out frequency coefficients that hash outside the bucket while passing through frequency coefficients that hash into the bucket. The simplest example of this is the aliasing filter. Recall the following basic property of the Fourier transform: <i>subsampling in the time domain causes aliasing in the frequency domain</i>. Formally, let <b>b</b> be a subsampled version of <b>x</b>, i.e., <i>b</i>(<i>i</i>) = <b>x</b>(<i>i</i> &#183; <i>p</i>) where <i>p</i> is a subsampling factor that divides <i>n</i>. Then, <b>b&#770;</b>, the Fourier transform of <b>b</b> is an aliased version of <b>x&#770;</b>, i.e.,</p>
<p class="eqn"><a id="eq1_3"/><img src="../images/eq1_3.png" alt="image"/></p>
<p class="noindent">Thus, an aliasing filter is a form of bucketization in which frequencies equally spaced by an interval <i>B = n/p</i> hash to the same bucket and there are <i>B</i> such buckets, as shown in <a href="#fig1_1">Figure 1.1</a>. The hashing function resulting from this bucketization can be written as: <i>h</i>(<i>f</i>) = <i>f</i> mod <i>n/p</i>. Further, the value in each bucket is the sum of the values of only the frequency coefficients that hash to the bucket as can be seen from <a href="#eq1_3">Equation 1.3</a>.</p>
<p class="indent">For the above aliasing filter, the buckets can be computed efficiently using a <i>B</i>-point FFT which takes <i>O</i>(<i>B</i> log <i>B</i>) time. We set <i>B</i> = <i>O</i>(<i>k</i>) and hence bucketization takes only <i>O</i>(<i>k</i> log <i>k</i>) time and uses only <i>O</i>(<i>B</i>) = <i>O</i>(<i>k</i>) of the input samples of <b>x</b>. <a id="page_7"/>In <a href="#ch1_1_3">Section 1.1.3</a>, we describe additional types of filters that are used by our Sparse Fourier Transform algorithms to perform frequency bucketization.</p>
<div class="cap">
<p class="image"><a id="fig1_1"/><img src="../images/fig1_1.png" alt="image"/></p>
<p class="figcaption"><b>Figure 1.1</b> Bucketization using aliasing filter. Subsampling a signal by 3&#215; in the time domain results in the spectrum aliasing. Specifically, the 12 frequency will alias into 4 buckets. Frequencies that are equally spaced by 4 (shown with the same color) end up in the same bucket.</p>
</div>
<p class="h3"><a id="ch1_1_2_2"/><b><span class="big2">1.1.2.2</span>&#160;&#160;&#160;&#160;Frequency Estimation</b></p>
<p class="noindent">In this step, the Sparse Fourier Transform estimates the positions and values of the non-zero frequency coefficients which created the energy in each of the non-empty buckets. Since <b>x&#770;</b> is sparse, many of the non-empty buckets will likely have a single non-zero frequency coefficient hashing into them, and only a small number will have a collision of multiple non-zero coefficients. We first focus on buckets with a single non-zero frequency coefficients and estimate the value and the position of this non-zero frequency, i.e., <b>x&#770;</b>(<i>f</i>) and the corresponding <i>f</i>.</p>
<p class="indent">In the absence of a collision, the value of the non-zero frequency coefficient is the value of the bucket it hashes to since all other frequencies that hash into the bucket have zero values. Hence, we can easily find the value of the non-zero frequency coefficient in a bucket. However, we still do not know its frequency position <i>f</i>, since frequency bucketization mapped multiple frequencies to the same bucket. The simplest way to compute <i>f</i> is to leverage the <i>phase-rotation property</i> of the Fourier transform, which states that a shift in time domain translates into phase rotation in the frequency domain [Lyons 1996]. Specifically, we perform the process of bucketization again, after a circular shift of <b>x</b> by <i>&#964;</i> samples. Since a shift in time translates into a phase rotation in the frequency domain, the value of the bucket changes from <b>b&#770;</b>(<i>i</i>) = <b>x&#770;</b>(<i>f</i>) to <b>b&#770;</b><sup>(<i>&#964;</i>)</sup>(<i>i</i>) = <b>x&#770;</b>(<i>f</i>) &#183; <i>e</i><sup><i>j</i>&#916;<i>&#981;</i></sup> where the phase rotation is</p>
<p class="eqn"><a id="eq1_4"/><img src="../images/eq1_4.png" alt="image"/></p>
<p class="noindent"><a id="page_8"/>Hence, using the change in the phase of the bucket, we can estimate the position of the non-zero frequency coefficient in the bucket. Note that the phase wraps around every 2<i>&#960;</i> and so the shift <i>&#964;</i> should be 1 to avoid the phase wrapping for large values of <i>f</i>.<sup><a id="fn1" href="#rfn1">1</a></sup> Since there are <i>k</i> non-zero frequency coefficients, this frequency estimation can be done efficiently using at most <i>O</i>(<i>k</i>) computations. In <a href="#ch1_1_3">Section 1.1.3</a>, we describe additional techniques that are used by our Sparse Fourier Transform algorithms to estimate the values and positions of non-zero frequency coefficients.</p>
<p class="h3"><a id="ch1_1_2_3"/><b><span class="big2">1.1.2.3</span>&#160;&#160;&#160;&#160;Collision Resolution</b></p>
<p class="noindent">Non-zero frequency coefficients that are isolated in their own bucket can be properly estimated, as described above. However, when non-zero frequencies collide in the same bucket, we are unable to estimate them correctly. Hence, to recover the full frequency spectrum, we need to resolve the collisions.</p>
<p class="indent">To resolve collision, we need to repeat the frequency bucketization in a manner that ensures that the same non-zero frequencies do not collide with each other every time. The manner in which we achieve this depends on the type of filter used for bucketization. For example, with the aliasing filters described above, we can bucketize the spectrum multiple times using aliasing filters with co-prime sampling rates. This changes the hashing function from <i>h</i>(<i>f</i>) = <i>f</i> mod <i>n/p</i> to <i>h</i>&#8242;(<i>f</i>) = <i>f</i> mod <i>n/p</i>&#8242; where <i>p</i> and <i>p</i>&#8242; are co-prime. Co-prime aliasing filters guarantee that any two frequencies that collide in one bucketization will not collide in the other bucketization. To better understand this point, consider the example in <a href="#fig1_2">Figure 1.2</a>. The first time we bucketize, we use an aliasing filter that subsamples the time signal by a factor of 3. In this case, the two frequencies labeled in red and blue collide in a bucket whereas the frequency labeled in green does not collide, as shown in the figure. The second time we bucketize, we use an aliasing filter that subsamples by 4. This time the blue and green frequencies collide whereas the red frequency does not collide. Now we can resolve collisions by iterating between the two bucketizations. For example, we can estimate the green frequency from the first bucketization, where it does not collide.<sup><a id="fn2" href="#rfn2">2</a></sup> We subtract the green frequency from the <a id="page_9"/>colliding bucket in the second bucketization to obtain the blue frequency. We then go back to the first bucketization and subtract the blue frequency from the bucket where it collides to obtain the red frequency.</p>
<div class="cap">
<p class="image"><a id="fig1_2"/><img src="../images/fig1_2.png" alt="image"/></p>
<p class="figcaption"><b>Figure 1.2</b> Resolving collisions with co-prime aliasing. Using two co-prime aliasing filters, we ensure the frequencies that collide in one filter will not collide in the second. For example, frequencies 5 and 9 collide in the first filter. But frequency 5 does not collide in the second which allows us to estimate it and subtract it.</p>
</div>
<p class="indent">Iterating between the different bucketizations by estimating frequencies from buckets where they do not collide and subtracting them from buckets where they do collide, ensures that each non-zero frequency will be isolated in its own bucket during some iteration of the algorithm. This allows us to estimate each non-zero frequency correctly. Thus, at the end of the of the collision resolution step, we have recovered all non-zero frequencies and hence have successfully computed the Fourier transform of the signal.</p>
<p class="h2"><a id="ch1_1_3"/><b><span class="big1">1.1.3</span>&#160;&#160;&#160;&#160;Algorithmic Techniques</b></p>
<p class="noindent">The previous section established a general framework for computing the Sparse Fourier Transform and gave one example of a technique that can be used in each step of this framework. In this section, we describe a more comprehensive list of techniques that are used by different Sparse Fourier Transform algorithms.</p>
<div class="cap">
<p class="image"><a id="page_10"/><a id="fig1_3"/><img src="../images/fig1_3.png" alt="image"/></p>
<p class="figcaption"><b>Figure 1.3</b> Filters used for frequency bucketization shown in the time (upper row) and the frequency (lower row) domain.</p>
</div>
<p class="h3"><a id="ch1_1_3_1"/><b><span class="big2">1.1.3.1</span>&#160;&#160;&#160;&#160;Frequency Bucketization Techniques</b></p>
<p class="noindent">As described earlier, bucketization is done using filters. The choice of the filter can severely affect the running time of a Sparse Fourier Transform algorithm. Ideally, we would like a filter that uses a small number of input time samples to hash the frequency coefficients into buckets. For example, the rectangular or boxcar filter shown in <a href="#fig1_3">Figure 1.3(a)</a>, uses only <i>B</i> time samples to hash the frequency coefficients into <i>B</i> buckets which is ideal in time domain. However, in the frequency domain, it is equal to the sinc function,<sup><a id="fn3" href="#rfn3">3</a></sup> which decays polynomially as shown in <a href="#fig1_3">Figure 1.3(a)</a>. This polynomial decay means that the frequency coefficients &#8220;leak&#8221; between buckets, i.e., the value of the bucket is no longer the sum of <i>n/B</i> coefficients that hash to the bucket. It is a weighted sum of all the <i>n</i> frequency coefficients. Hence, a nonzero frequency coefficient can never be isolated in a bucket and estimated correctly. One the other hand, a rectangular filter is ideal in the frequency domain since it has no leakage, as shown in <a href="#fig1_3">Figure 1.3(b)</a>. However, it is sinc function in the time domain and hence requires using all <i>n</i> input samples which take at least &#937;(<i>n</i>) time to process.</p>
<p class="indent">In this book, we identify several efficient filters that use a small number of samples in time domain and have minimal or no leakage in the frequency domain and as a result can be used to perform fast bucketization.</p>
<p class="hang"><a id="page_11"/><b>Flat Window Filter.</b> This filter looks very similar to a rectangle or box in the frequency domain while still using a small number of time samples. An example of such filter is a Gaussian function multiplied by a sinc function in the time domain which is shown in <a href="#fig1_3">Figure 1.3(c)</a>. Since the Gaussian function decays exponentially fast both in time and frequency, the leakage between buckets in this filter is negligible and can be ignored. Similarly, the filter is concentrated in time and hence uses only a small number of time samples. The resulting hash function of such filter can be written as <i>h</i>(<i>f</i>) = &#8968;<i>f</i>/(<i>n/B</i>)&#8969;. Gaussian is only one example of such functions. One can potentially use a Dolph-Chebyshev or a Kaiser-Bessel function as we describe in more detail in <a href="11_Chapter02.xhtml">Chapter 2</a>.</p>
<p class="hang"><b>Aliasing Filter.</b> We presented this filter in the previous section. It is simply a spike-train of period <i>p</i> in time domain since it subsamples the time domain signal by a factor of <i>p</i>, as shown in <a href="#fig1_3">Figure 1.3(d)</a>. It is also a spike-train in the frequency domain since it sums up frequency coefficients that are equally spaced by <i>n/p</i>. The aliasing filter is ideal both in time and in frequency since it only uses <i>B</i> time samples and has zero leakage between buckets. Unfortunately, we will later show that the aliasing filter does not lend itself to powerful randomization techniques and, as a result, can only be shown to work for average case input signals as opposed to worst case.</p>
<p class="hang"><b>Fourier Projection Filter.</b> This filter is a generalization of the aliasing filter to higher dimensions. It is a direct result of the <i>Fourier Slice Projection Theorem</i> which states that taking the Fourier transform of samples along a slice (e.g., a 1D line in 2D time signal or a 2D plane in a 3D signal) results in the orthogonal projection of the frequency spectrum onto the corresponding slice in the Fourier domain. For example, if we sample a row in a 2D time domain signal and then take its 1D Fourier transform, each output point of the Fourier transform will be the sum of the coefficients along one column, as shown in <a href="#fig1_4">Figure 1.4(a)</a>. Alternatively, if we sample a column, each output point will be the sum of the coefficients along one row, as shown in <a href="#fig1_4">Figure 1.4(b)</a>. This also holds for any discrete line, as shown in <a href="#fig1_4">Figure 1.4(c,d)</a>. Thus, if we sample a line with slope equal to 1 or 2, we get a projection in the frequency domain along lines with slopes equal to &#8722;1or &#8722;1/2. Note that discrete lines wrap around and hence can generate non-uniform sampling, as shown in <a href="#fig1_4">Figure 1.4(d)</a>.</p>
<div class="cap">
<p class="image"><a id="page_12"/><a id="fig1_4"/><img src="../images/fig1_4.png" alt="image"/></p>
<p class="figcaption"><b>Figure 1.4</b> Fourier projection filters. The top row of figures shows the sampled lines of the time signal and the bottom row of figures shows how the spectrum is projected. Frequencies of the same color are projected onto the same point: (a) row projection, (b) column projection, (c) diagonal projection, and (d) line with slope = 2.</p>
</div>
<p class="h3"><a id="ch1_1_3_2"/><b><span class="big2">1.1.3.2</span>&#160;&#160;&#160;&#160;Frequency Estimation Techniques</b></p>
<p class="noindent">Recall that the goal of the frequency estimation step is to compute the positions <i>f</i> and values <b>x&#770;</b>(<i>f</i>) of the non-zero frequency coefficients that have been hashed to non-empty buckets. In what follows, we will present the techniques used by the Sparse Fourier Transform algorithms to perform frequency estimation.</p>
<p class="hang"><b>Time-Shift/Phase-Rotation Approach.</b> In this approach, which we have previously described in <a href="#ch1_1_2">Section 1.1.2</a>, we repeat the bucketization after shifting the time signal <b>x</b> by a circular shift of <i>&#964;</i> samples. For buckets with a single isolated non-zero frequency coefficient, this results in a phase rotation &#916;<i>&#981;</i> of the complex value of the coefficient. &#916;<i>&#981;</i> = 2<i>&#960;f&#964;</i>/<i>n</i> which we can use to compute the frequency position <i>f</i>. Since the frequency is isolated, its value can be immediately computed from the value of the bucket as described in the previous section. This is an extremely efficient approach since it requires constant <i>O</i>(1) time to estimate each non-zero frequency. For noisy signals, we repeat this process for multiple different time shifts to average the noise. The details of how we average the noise to ensure robust recovery can be found in <a href="13_Chapter04.xhtml">Chapter 4</a>.</p>
<p class="hang"><a id="page_13"/><b>Voting Approach.</b> This is a non-iterative streaming approach where we repeat the bucketization few times while changing the hashing function. For each bucketization, the non-empty buckets vote for all the frequency coefficients that hash into those buckets. Non-zero frequency coefficients will get a vote from every bucketization with high probability. On the other hand, zero and negligible frequencies are unlikely to get many votes. Hence, after repeating the bucketization and this voting procedure a few times, the <i>k</i> non-zero frequency coefficients will have the largest number of votes and can be identified. In <a href="12_Chapter03.xhtml">Chapter 3</a>, we will show that this approach is more resilient to signal noise. However, this comes at the cost of increased runtime which we prove to be <img src="../images/in13_1.png" alt="image"/>.</p>
<p class="h3"><a id="ch1_1_3_3"/><b><span class="big2">1.1.3.3</span>&#160;&#160;&#160;&#160;Collision Resolution Techniques</b></p>
<p class="noindent">Collision resolution is achieved by repeating the bucketization in a manner that changes the way frequency coefficients hash into buckets so that the same coefficients do not continue to collide.</p>
<p class="indent">We can randomize the hashing function if we can perform a random permutation of the positions of the coefficients in <b>x&#770;</b> before repeating the bucketization. This can be achieved by rearranging the indices of the input time signal <b>x</b> and rescaling it in the following manner:<sup><a id="fn4" href="#rfn4">4</a></sup></p>
<p class="eqn"><a id="eq1_5"/><img src="../images/eq1_5.png" alt="image"/></p>
<p class="noindent">where <i>&#963;</i> is a random integer invertible modulo <i>n</i> and <i>&#946;</i> is a random integer. This results in a random linear mapping of the positions of the frequency coefficients: <i>f</i> &#8594; <i>&#963;</i><sup>&#8722;1</sup><i>f</i> + <i>&#946;</i> mod <i>n</i>. The proof of this can be found in <a href="11_Chapter02.xhtml">Chapter 2</a>. While this randomization is a very powerful collision resolution technique, it only works with the flat window filter and does not work with aliasing filters as we will show in <a href="12_Chapter03.xhtml">Chapter 3</a>. To resolve collisions using aliasing filters, we need to use co-prime subsampling, i.e., subsample the signal using different co-prime subsampling rates as explained in the previous section.</p>
<p class="h2"><a id="ch1_1_4"/><b><span class="big1">1.1.4</span>&#160;&#160;&#160;&#160;Algorithmic Results</b></p>
<p class="noindent">In this section, we will present the theoretical results of the Sparse Fourier Transform algorithms that we developed. All the algorithms follow the framework described in <a href="#ch1_1_2">Section 1.1.2</a>. However, they use different techniques from <a href="#ch1_1_3">Section 1.1.3</a> <a id="page_14"/>and as a result achieve different runtime and sampling complexities as well as different guarantees. Most of the theoretical algorithms presented in this book are randomized and succeed with a large constant probability. <a href="#tab1_2">Table 1.2</a> summarizes the theoretical Sparse Fourier Transform algorithms presented in this book along with their complexity results, guarantees, and techniques used.</p>
<p class="h1"><b><a id="ch1_2"/><span class="big">1.2</span>&#160;&#160;&#160;&#160;Applications of the Sparse Fourier Transform</b></p>
<p class="noindent">The second half of this book focuses on developing software and hardware systems that harness the Sparse Fourier Transform to solve practical problems. The book presents the design and implementation of six new systems that solve challenges in the areas of wireless networks, mobile systems, computer graphics, medical imaging, biochemistry, and digital circuits. All six systems are prototyped and evaluated in accordance with the standards of each application&#8217;s field.</p>
<p class="indent">Adapting the Sparse Fourier Transform to a particular application requires a careful design and deep knowledge of the application domain. The Sparse Fourier Transform is a framework of algorithms and techniques for analyzing sparse signals. It is not a single algorithm that can be plugged directly into an application. To apply it to a problem, one has to deeply understand the structure of the sparsity in the application of interest, and customize the framework to the observed sparsity. More generally, real applications add new constraints that are application-dependent, and can deviate from our mathematical abstraction. Below we highlight some of the common themes that arise in mapping the Sparse Fourier Transform to practical systems.</p>
<p class="hang"><b>Structure of Sparsity.</b> In most applications, the occupied frequency coefficients are not randomly distributed; they follow a specific structure. For example, as mentioned earlier, in wireless communication, the occupied frequencies in the wireless spectrum are clustered. In computational photography, the occupied frequencies are more likely to be present in part of the Fourier spectrum. On the other hand, in an application like GPS, the occupied coefficient can be anywhere. Understanding the structure of sparsity in each application allows us to design a system that leverages it to achieve the best performance gains.</p>
<p class="hang"><b>Level of Sparsity.</b> A main difference between theory and practice is that the Sparse Fourier Transform algorithms operate in the discrete domain. In real and natural signals, however, the frequency coefficients do not necessarily lie on discrete grid points. Simply rounding off the locations of the coefficients to the nearest grid points can create bad artifacts which significantly reduce the sparsity of the signal and damage the quality of the results. This problem occurs in application like medical imaging and light-field photography. Hence, we have to design systems that can sparsify the signals and recover their original sparsity in the continuous domain in order to address the mismatch between the theoretical Sparse Fourier Transform framework and the scenarios in which it is applied.</p>
<p class="tcaption"><a id="page_15"/><a id="tab1_2"/><b>Table 1.2</b> Theoretical Sparse Fourier Transform algorithms</p>
<p class="image"><img src="../images/tab1_2.png" alt="image"/></p>
<p class="tsource">a. The sampling complexity of algorithms SFT 1.0&#8211;4.1 is the same as their runtime complexity.</p>
<p class="hang"><a id="page_16"/><b>System Requirements.</b> Different applications have different goals. For example, in medical imaging, the acquisition cost is high since it requires the patient to spend more time in the MRI machine while processing the captured data afterward is not a problem. Hence, the goal would be to minimize the number of input samples that need to be collected even if it requires additional processing time. On the other hand, in applications like GPS, collecting the samples is very cheap. However, processing them consumes a lot of power. Hence, the goal would be to minimize computational load even if all the input samples are used. Finally, in applications like spectrum acquisition and NMR spectroscopy, the goal would be to minimize both the runtime and the sampling. Hence, understanding the system is essential for adapting the Sparse Fourier Transform techniques to satisfy the requirements of each application.</p>
<p class="hang"><b>System Architecture.</b> In some applications, the applicability of the Sparse Fourier Transform to a system architecture might not even be apparent. For example, the Fourier transform of the GPS signal is not sparse and hence applying the Sparse Fourier Transform directly to GPS is not feasible. However, we observed that the GPS receiver correlates its signal with a special code transmitted by the satellite, and the output of the correlation is sparse because it spikes only when the code and the signal are aligned. Hence, we have to map this indirect form of sparsity to the Sparse Fourier Transform framework. We also need to ensure that the gains of the Sparse Fourier Transform are not bottlenecked by other components in the system. Thus, careful system design is essential for propagating these gains along the system pipeline and improving the overall system performance.</p>
<p class="hang"><b>Signal to Noise Ratio.</b> In practice, the gains of the Sparse Fourier Transform are constraint by the noise level in the system. It is essential to perform sampling and processing that would be sufficient to bring the signal above the noise floor of the system. For example, although the sparsity that appears in a GPS <a id="page_17"/>system is extremely high (&#8776;0.025%), GPS signals are -30 dB to -20 dB below the noise floor which requires additional computation that upper bounds the performance gains. Thus, understanding the noise level and structure is essential in designing any system that uses the Sparse Fourier Transform.</p>
<p class="indentt">The following subsections summarize the systems presented in this book and how they benefit from the Sparse Fourier Transform.</p>
<p class="h2"><a id="ch1_2_1"/><b><span class="big1">1.2.1</span>&#160;&#160;&#160;&#160;Spectrum Sensing and Decoding</b></p>
<p class="noindent">The ever-increasing demand for wireless connectivity has led to a spectrum shortage which prompted the FCC to release multiple new bands for dynamic spectrum sharing. This is part of a bigger vision to dynamically share much of the currently under-utilized spectrum, creating GHz-wide spectrum superhighways that can be shared by different types of wireless services. However, a major technical obstacle precluding this vision is the need for receivers that can capture and sense GHz of spectrum in real-time in order to quickly identify unoccupied bands. Such receivers consume a lot of power because they need to sample the wireless signal at GigaSample/s.</p>
<p class="indent">To overcome this challenge, we leverage the fact that the wireless spectrum is sparsely utilized and use the Sparse Fourier Transform to build a receiver that can capture and recover GHz of spectrum in real-time, while sampling only at MegaSample/s. We use the aliasing filters and phase rotation techniques described in <a href="#ch1_1_3">Section 1.1.3</a> to build the entire receiver using only cheap, low power hardware similar to what is used today by WiFi and LTE in every mobile phone. We implement our design using three software radios, each sampling at 50 MegaSample/s, and produce a device that captures 0.9 GHz, i.e., 6&#215; larger digital bandwidth than the three software radios combined. The details of the system design, implementation, and evaluation can be found in <a href="17_Chapter07.xhtml">Chapter 7</a>.</p>
<p class="h2"><a id="ch1_2_2"/><b><span class="big1">1.2.2</span>&#160;&#160;&#160;&#160;GPS Receivers</b></p>
<p class="noindent">GPS is one of the most widely used wireless systems. In order to calculate its position, a GPS receiver has to lock on the satellite signals by aligning the received signal with each satellite&#8217;s code. This process requires heavy computation, which consumes both time and power. As a result, running GPS on a phone can quickly drain the battery.</p>
<p class="indent">We introduced a new GPS receiver that minimizes the required computation to lock on the satellite&#8217;s signal hence reducing localization delay and power consumption. Specifically, we observed that GPS synchronization can be reduced into a <a id="page_18"/>sparse computation problem by leveraging the fact that only the correct alignment between the received GPS signal and the satellite code causes their correlation to spike. We built on this insight to develop a GPS receiver that exploits the Sparse Fourier Transform to quickly lock on the satellite signal and identify its location. We prototyped this design using software radios. Our empirical results with real satellite signals demonstrate that the new GPS receiver reduces the computational overhead by 2&#215; to 6&#215;, which translates into significant reduction in localization delay and power consumption. <a href="18_Chapter08.xhtml">Chapter 8</a> presents the analysis and evaluation of the design in detail.</p>
<p class="h2"><a id="ch1_2_3"/><b><span class="big1">1.2.3</span>&#160;&#160;&#160;&#160;Light Field Photography</b></p>
<p class="noindent">Light field photography is an active area in graphics where a 2D array of cameras or lenslets is used to capture the 4D light field of a scene.<sup><a id="fn5" href="#rfn5">5</a></sup> This enables a user to extract the 3D depth, refocus the scene to any plane, and change the angle from which he views the scene. This is essential for Virtual Reality (VR) systems as well as post processing of images and videos. Capturing light fields, however, is costly since it requires many cameras or lenslets to sample the scene from different viewpoints.</p>
<p class="indent">Thus, our goal is to reduce the cost of light field capture by using only few of the cameras in the 2D array and reconstructing the images from the missing cameras. To do this, we leverage the fact that the 4D Fourier transform of a light field is sparse and we use the Sparse Fourier Transform to subsample the input and reduce the number of cameras. Once we have computed the Fourier transform, we can invert it back to recover the images from the missing cameras which were not sampled and hence recover the full 2D array. However, as explained earlier, natural signals like light fields are not very sparse in the discrete domain. To address this issue, we developed a light field reconstruction system that optimizes for sparsity in the continuous Fourier domain. This improves the quality of reconstruction while reducing the required number of cameras by 6&#215; to 10&#215;. The light field reconstruction algorithm along with the reconstruction results can be found in <a href="19_Chapter09.xhtml">Chapter 9</a>.</p>
<p class="h2"><a id="ch1_2_4"/><b><span class="big1">1.2.4</span>&#160;&#160;&#160;&#160;Magnetic Resonance Spectroscopy (MRS)</b></p>
<p class="noindent">One of the next frontiers in MRI is Magnetic Resonance Spectroscopy (MRS). MRS enables zooming in and detecting the biochemical content of each voxel in the <a id="page_19"/>brain, which can be used to discover disease biomarkers that allow early detection of cancer, autism, and Alzheimer&#8217;s. MRS tests, however, take prohibitively long time, requiring the patient to stay in the MRI machine for more than 2 hr. MRS images also suffer from a lot of clutter and artifacts that can mask some disease biomarkers. These two challenges have been a major barrier against adopting these tests in clinical diagnosis. To overcome this barrier, we demonstrated that processing MRS data using the Sparse Fourier Transform enhances image quality by suppressing artifacts and reduces the time the patient has to spend in the machine by 3&#215; (e.g., from 2 hr to 40 mins). The details of our MRS algorithm, experiments and results can be found in <a href="20_Chapter10.xhtml">Chapter 10</a>.</p>
<p class="h2"><a id="ch1_2_5"/><b><span class="big1">1.2.5</span>&#160;&#160;&#160;&#160;Nuclear Magnetic Resonance (NMR)</b></p>
<p class="noindent">NMR is a technique that provides the detailed structural properties of chemical compounds, providing the 3D structure of complex proteins and nucleic acids. However, collecting NMR measurements is a very time consuming and costly process that can take from several days up to weeks. This prevents researchers from running high-dimensional NMR experiments which are needed for analyzing more complex protein structures. NMR uses spectral analysis to find the resonance frequencies that correspond to the coupling between different atoms. NMR spectra are sparse. Hence, using the Sparse Fourier Transform, we show how to generate the NMR spectra by subsampling the NMR measurements. We customized the Sparse Fourier Transform for multi-dimensional NMR and showed that it can reduce the time of an NMR experiment by 16&#215;. <a href="21_Chapter11.xhtml">Chapter 11</a> describes the Sparse Fourier Transform techniques used for processing our NMR experiments along with our recovery results.</p>
<p class="h2"><a id="ch1_2_6"/><b><span class="big1">1.2.6</span>&#160;&#160;&#160;&#160;The Sparse Fourier Transform Chip</b></p>
<p class="noindent">Traditionally, hardware implementations of FFT have been limited in size to few thousands of points. This is because large FFTs require a huge I/O bandwidth, consume a lot of power, and occupy a large silicon area. The Sparse Fourier Transform naturally addresses these issues due to its low computational and memory cost, enabling very large Fourier transforms. We built the largest Fourier transform VLSI chip to date with nearly a million point Fourier transform while consuming 40&#215; less power than prior FFT VLSI implementations. The hardware architecture and benchmarking of the fabricated chip can be found in <a href="29_Appendix07.xhtml">Appendix G</a>.</p>
<p class="h1"><a id="page_20"/><b><a id="ch1_3"/><span class="big">1.3</span>&#160;&#160;&#160;&#160;Book Overview</b></p>
<p class="noindent">This book is divided into two parts. <a href="10_Part01.xhtml">Part I</a> describes the theoretical foundations of the Sparse Fourier Transform. It presents the Sparse Fourier Transform algorithms in detail and provides the analysis and proofs of the guarantees of these algorithms. <a href="11_Chapter02.xhtml">Chapter 2</a> presents the notation and basic definitions that will be used in this part of the book. <a href="12_Chapter03.xhtml">Chapters 3</a> and <a href="13_Chapter04.xhtml">4</a> focus on reducing the runtime complexity of the Sparse Fourier Transform algorithms while <a href="14_Chapter05.xhtml">Chapter 5</a> focuses on optimizing the sample complexity. Finally, in <a href="15_Chapter06.xhtml">Chapter 6</a>, we present numerical simulations to evaluate the performance of the Sparse Fourier Transform.</p>
<p class="indent"><a href="16_Part02.xhtml">Part II</a> describes the applications and systems designed using the Sparse Fourier Transform. <a href="17_Chapter07.xhtml">Chapter 7</a> describes the design and implementation of a wireless receiver that can capture GHz of spectrum in real time. <a href="18_Chapter08.xhtml">Chapter 8</a> presents a GPS receiver design with lower computational overhead. <a href="19_Chapter09.xhtml">Chapter 9</a> describes a light field photography reconstruction algorithm that achieves high quality image recovery. <a href="20_Chapter10.xhtml">Chapter 10</a> shows how the Sparse Fourier Transform can be used to reduce the time a patient spends in an MRI machine and generate clearer images. <a href="21_Chapter11.xhtml">Chapter 11</a> presents the application of the Sparse Fourier Transform to Nuclear Magnetic Resonance in biochemistry.</p>
<p class="indent">Finally, in <a href="22_Chapter12.xhtml">Chapter 12</a>, we conclude and discuss future algorithms and applications of the Sparse Fourier Transform.</p>
<p class="line"/>
<p class="foot"><a id="rfn1" href="#fn1">1</a>. Note that for approximately sparse signals, multiple time shifts are used to average the noise and ensure robust estimation as we show in <a href="13_Chapter04.xhtml">Chapter 4</a>.</p>
<p class="foot"><a id="rfn2" href="#fn2">2</a>. In <a href="14_Chapter05.xhtml">Chapter 5</a>, we will present techniques to detect collisions. However, accurately detecting collision is not always necessary. Since <b>x&#770;</b> is sparse, the number of collisions will be very small and errors caused by assuming a non-zero frequency is isolated when it is in a collision can be corrected in subsequent iterations of the algorithm.</p>
<p class="foot"><a id="rfn3" href="#fn3">3</a>. The sinc function is defined as: <i>sinc</i>(<i>x</i>) = <i>sin</i>(<i>x</i>)/<i>x</i>.</p>
<p class="foot"><a id="rfn4" href="#fn4">4</a>. Note that only time samples that will be used by the bucketization filters need to be computed.</p>
<p class="foot"><a id="rfn5" href="#fn5">5</a>. The four dimensions of a light field correspond to the 2D pixels in each image captured by a camera in the 2D camera array.</p>
</body>
</html>
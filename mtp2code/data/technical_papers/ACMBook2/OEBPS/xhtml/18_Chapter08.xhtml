<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Sparse Fourier Transform: Theory and Practice</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="../styles/page-template.xpgt"/>
</head>
<body>
<p class="chno"><a id="page_105"/><b>8</b></p>
<p class="chtitle"><b>Faster GPS Synchronization</b></p>
<p class="h1"><b><a id="ch8_1"/><span class="big">8.1</span>&#160;&#160;&#160;&#160;Introduction</b></p>
<p class="noindent">The global positioning system (GPS) is one of the most pervasive wireless technologies. It is incorporated in more than one billion smartphones world-wide [Hepburn 2011], and embedded in a wide variety of devices, including personal navigation systems [Ted Schadler 2017], sensors [Dexter Industries 2017], digital cameras [Nikon USA 2017], and even under-the-skin bio-chips [Gossett 2003]. The key functionality of a GPS receiver is to calculate a position, called a fix. Computing a fix involves locking on the GPS satellite signals and decoding satellite orbit and time data. Most GPS receivers, however, are embedded with some other radio (e.g., WiFi, cellular, or ZigBee) and, hence, can download the content of the GPS signal from assisted GPS (A-GPS) servers instead of decoding it from the satellite signals [Jani Jarvinen and DeSalas 2002].<sup><a id="fn1" href="#rfn1">1</a></sup> With assisted GPS used widely in phones and other GPS-capable devices [Fleishman 2011], the bulk of what a GPS receiver does is to lock on the satellite signal (i.e., synchronize with it). This allows the receiver to calculate the sub-millisecond synchronization delay necessary for computing its position [Fleishman 2009]. The importance of locking is further emphasized by the fact that current GPS receivers are typically duty-cycled [Buchli et al. 2012, Raskovic and Giessel 2007]; hence, they need to re-synchronize with the satellite signals regularly. Synchronizing with the satellite signal, however, is a costly process that requires tens of millions to a few billion digital multiplications [Team 2000]. Many GPS-enabled devices (e.g., mobile phones, sensors, etc.) have strict power limitations and would benefit from reducing the complexity of this process.</p>
<p class="indent"><a id="page_106"/>In this chapter, we aim to reduce the cost of synchronizing with weak signals like GPS. At a high level, GPS synchronization works as follows: each satellite is assigned a CDMA code. For each satellite, the receiver needs to align the corresponding CDMA code with the received signal. The process is complicated because GPS signals are very weak (about 20 dB <i>below</i> the noise level [Plausinaitis 2017]). To find the right alignment of each satellite, a GPS receiver conducts a search process. It computes the correlation of the CDMA code with the received signal for all possible shifts of the code with respect to the signal. The correct shift is the one that maximizes the correlation.</p>
<p class="indent">So, how does a GPS receiver compute all these shifted correlations? The traditional approach <i>convolves</i> the received signal with the CDMA code of each satellite in the time domain. The correct alignment corresponds to the one that maximizes this convolution. This approach has a computational complexity of <i>O</i>(<i>n</i><sup>2</sup>), where <i>n</i> is the number of samples.<sup><a id="fn2" href="#rfn2">2</a></sup> More recent GPS receivers lock on the satellite using frequency domain computation. This approach leverages the fact that convolution in the time domain corresponds to multiplication in the frequency domain. It proceeds in the following three steps, shown in <a href="#fig8_1">Figure 8.1</a>: (1) the receiver takes the FFT of the received signal; (2) it multiplies the output of this Fourier transform by the FFT of the CDMA code; and (3) it performs the inverse FFT on the resulting signal. This three-step process is mathematically equivalent to convolving the signal with the code; thus, the output of the inverse FFT will spike at the correct shift that synchronizes the code with the received signal, as shown in <a href="#fig8_1">Figure 8.1(d)</a>. The computational complexity of this approach is <i>O</i>(<i>n</i> log <i>n</i>). For the past two decades, this has been the algorithm with the lowest computational complexity for synchronizing a GPS receiver [Team 2000].</p>
<p class="indent">This chapter introduces the lowest complexity GPS synchronization algorithm to date. Our synchronization algorithm is based on the following observations.</p>
<p class="bull">&#8226;&#160;&#160;First, we note that since the output of the synchronization process has a single major spike at the correct shift, as shown in <a href="#fig8_1">Figure 8.1(d)</a>, the inverse <a id="page_107"/>FFT is very sparse. We build on the Sparse Fourier Transform algorithms from <a href="10_Part01.xhtml">Part I</a> of this book to significantly reduce the runtime of the GPS synchronization algorithm.<sup><a id="fn3" href="#rfn3">3</a></sup> However, the Sparse Fourier Transform algorithms presented in <a href="10_Part01.xhtml">Part I</a> use relatively complex filters and estimation techniques to deal with the interaction of multiple potential spikes at the output of the transform. In contrast, here, we exploit the fact that the synchronization problem produces only one spike, and design a simple sublinear algorithm that uses only aliasing to filter the signal. This allows us to reduce the complexity of the IFFT step in <a href="#fig8_1">Figure 8.1(d)</a> to sublinear time.</p>
<div class="cap">
<p class="image"><a id="fig8_1"/><img src="../images/fig8_1.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.1</b> FFT-based GPS synchronization algorithm. The algorithm multiplies the FFTs of the received signal with the FFT of the code, and takes the IFFT of the resulting signal. The output of the IFFT spikes at the shift that correctly synchronizes the code with the satellite signal.</p>
</div>
<p class="bull">&#8226;&#160;&#160;Although the output of the inverse FFT is sparse and can be quickly computed, the GPS signal in the frequency domain is not sparse (<a href="#fig8_1">Figure 8.1(b)</a>) and, hence, the runtime of the forward FFT cannot be reduced by applying a Sparse Fourier Transform. Thus, simply using Sparse Inverse Fourier Transform does not reduce the overall complexity of the problem (which is still <i>O</i>(<i>n</i> log <i>n</i>) due to the forward FFT). To address this issue, we note that the FFT in <a href="#fig8_1">Figure 8.1(b)</a> is just an intermediate step that will be used as an input to the Sparse Inverse Fourier Transform. Since the Sparse Inverse Fourier Transform algorithms operate only on a subset of their input signal, we do <a id="page_108"/>not need to compute the values of all frequencies at the output of the forward FFT. We leverage this property to compute only a subset of the frequencies and reduce the complexity of the FFT step.</p>
<p class="indentt">We provide an algorithm that, for any SNR, is as accurate as the original FFT-based (or convolution-based) algorithm, but reduces the computational complexity from <i>O</i>(<i>n</i> log <i>n</i>) operations to <img src="../images/in108_1.png" alt="image"/>. Further, when the noise in the received signal can be bounded by <i>O</i>(<i>n</i>/ log<sup>2</sup> <i>n</i>), we prove that the same algorithm has a linear complexity, i.e., <i>O</i>(<i>n</i>).<sup><a id="fn4" href="#rfn4">4</a></sup></p>
<p class="indent">We implement our design and test it on two datasets of GPS signals. We collected the first dataset in the U.S. using software radios. The second dataset was collected in Europe.<sup><a id="fn5" href="#rfn5">5</a></sup> The datasets cover both urban and suburban areas. We compare our design against an FFT-based synchronization algorithm. Our design reduces the number of multiplications for detecting the correct shift by a median of 2.2&#215;. Since a large fraction of GPS power is consumed by the synchronization process (30% [OriginGPS 2017] to 75% [Perthold Engineering LLC 2017] depending on the required accuracy), we expect the new design to produce a significant reduction in GPS power consumption.</p>
<p class="indent">Finally, this chapter makes both algorithmic and systems contributions, which can be summarized as follows.</p>
<p class="bull">&#8226;&#160;&#160;It presents the fastest algorithm to date for synchronizing GPS receivers with satellite signals. The algorithm has multiple features: (1) it is adaptive, i.e., it can finish faster if the SNR is higher; (2) it continues to work at very low SNRs; and (3) it is general, i.e., it can be used to synchronize any signal with a random (or pseudo random) code.</p>
<p class="bull">&#8226;&#160;&#160;It provides an implementation and an empirical evaluation on real GPS signals, demonstrating that the algorithmic gains translate into a significant reduction in the number of operations performed by a GPS receiver.</p>
<div class="cap">
<p class="image"><a id="page_109"/><a id="fig8_2"/><img src="../images/fig8_2.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.2</b> GPS trilateration: After determining the distance to different satellites, the receiver can draw spheres centered at each of the satellites and whose radii are the respective distances. These spheres should intersect at the receiver&#8217;s position. A GPS receiver needs four satellites to uniquely determine its position [Kaplan 1996]. Extra satellites can be used to correct for the lack of very tight synchronization between the receiver&#8217;s clock and those of the satellites.</p>
</div>
<p class="h1"><b><a id="ch8_2"/><span class="big">8.2</span>&#160;&#160;&#160;&#160;GPS Primer</b></p>
<p class="noindent">The key functionality of a GPS receiver is to calculate its position using the signal it receives from the GPS satellites. To do so, the receiver computes the time needed for the signal to travel from each satellite to itself. It then multiplies the computed time by the speed of light to obtain its distance from each satellite. As a result, the receiver knows that it lies on a sphere centered at that satellite and whose radius is the computed distance. It then determines its position as the intersection of several such spheres through a method called trilateration [Kaplan 1996], shown in <a href="#fig8_2">Figure 8.2</a>.</p>
<p class="indent">But how does the receiver compute the propagation time from the satellites? The propagation time is obtained using a synchronization algorithm that allows the device to lock on the received signal. Specifically, each satellite has its own CDMA code, called the C/A code, which consists of 1,023 chips [Kaplan 1996]. Assuming the receiver&#8217;s and satellites&#8217; clocks are perfectly synchronized, a GPS receiver generates the satellites&#8217; codes at the same time as the satellites. Due to propagation delay, however, the signal arrives in a shifted version at the receiver <a id="page_110"/>by exactly the amount of time it took the signal to travel from the satellite. By correlating with shifted versions of the satellite&#8217;s code, the receiver calculates the propagation time as the shift at which the correlation spikes [Team 2000]. In practice, the receiver&#8217;s clock is not fully synchronized with that of the satellites; this, however, can be compensated for by increasing the number of satellites used in the trilateration process.<sup><a id="fn6" href="#rfn6">6</a></sup></p>
<div class="cap">
<p class="image"><a id="fig8_3"/><img src="../images/fig8_3.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.3</b> 2D search for peak correlation. The plot shows the result of correlating with a C/A code for a satellite whose signal is present in the received signal. On the x-axis, we search 4,000 different code shifts and on the y-axis 21 different Doppler shifts.</p>
</div>
<p class="indent">The motion of the satellites introduces a Doppler shift in the received signal. The signal does not correlate with the C/A code unless the Doppler shift is corrected. To deal with this issue, a GPS device typically performs a 2D search on the received signal [Kaplan 1996]: one for time (code shifts), and one for Doppler shifts. Specifically, the receiver tries all possible code shifts, and 41 equally spaced Doppler shifts within &#177;10 kHz of the center frequency [Team 2000], as shown in <a href="#fig8_3">Figure 8.3</a>. Finally, the GPS satellites repeat the code 20 times for each data bit to enable the GPS receiver to decode very weak signals. The receiver tries to use one code repetition to synchronize. However, if the signal is too weak, the receiver repeats the 2D search for multiple codes and sums the result [Kaplan 1996].</p>
<p class="h1"><a id="page_111"/><b><a id="ch8_3"/><span class="big">8.3</span>&#160;&#160;&#160;&#160;QuickSync</b></p>
<p class="noindent">We describe QuickSync, a synchronization algorithm for GPS receivers. The algorithm works in the frequency domain similar to the FFT-based algorithm described in <a href="#ch8_1">Section 8.1</a>. QuickSync, however, exploits the sparse nature of the synchronization problem, where only the correct alignment between the received GPS signal and the satellite code causes their cross-correlation to spike. QuickSync harnesses this property to perform both the Fourier and inverse Fourier transforms in a time faster than <i>O</i>(<i>n</i> log <i>n</i>), therefore reducing the overall complexity of GPS synchronization.</p>
<p class="indent">The next subsections formalize the problem and detail the algorithm.</p>
<p class="h2"><a id="ch8_3_1"/><b><span class="big1">8.3.1</span>&#160;&#160;&#160;&#160;Problem Formulation</b></p>
<p class="noindent">The synchronization problem can be formulated as follows. Given a spreading code <b>c</b> = <i>c</i><sub>0</sub>, &#8230;, <i>c</i><sub><i>n</i>&#8722;1</sub> of size <i>n</i> and a received signal <b>x</b> = <i>x</i><sub>0</sub>, &#8230;, <i>x</i><sub><i>n</i>&#8722;1</sub>, find the time shift <i>t&#770;</i> that maximizes the correlation between <b>c</b> and <b>x</b>, i.e., compute</p>
<p class="eqn"><a id="eq8_1"/><img src="../images/eq8_1.png" alt="image"/></p>
<p class="noindent">where <img src="../images/in111_1.png" alt="image"/> is a circular convolution and <b>c</b><sub>&#8211;<i>n</i></sub> is the time reversed code, i.e., <b>c</b><sub>&#8722;<i>n</i></sub> = <i>c</i><sub><i>n</i>&#8722;1</sub>, &#8230;, <i>c</i><sub>0</sub>. Computing this convolution in the time domain requires performing <i>n</i> correlations each of size <i>n</i> and thus has complexity <i>O</i>(<i>n</i><sup>2</sup>). However, convolution in the time domain corresponds to element-by-element multiplication in the frequency domain. Therefore, computing the convolution in <a href="#eq8_1">Equation 8.1</a> can be done more efficiently by performing FFT on each of the code and the signal, multiplying those FFTs, then performing an inverse FFT (IFFT), as shown here:</p>
<p class="eqn"><a id="eq8_2"/><img src="../images/eq8_2.png" alt="image"/></p>
<p class="noindent">where <span class="f2">F</span>{&#183;} is the FFT, <span class="f2">F</span><sup>&#8722;1</sup>{&#183;} is the IFFT, * is the complex conjugate, and <i>t</i> is any time sample in the output vector of the convolution. This reduces the complexity of the synchronization process to <i>O</i>(<i>n</i> log(<i>n</i>)). Accordingly, in the remainder of this chapter, we only consider the FFT-based synchronization algorithm as a baseline for evaluating QuickSync&#8217;s performance.</p>
<p class="h2"><a id="ch8_3_2"/><b><span class="big1">8.3.2</span>&#160;&#160;&#160;&#160;Basics</b></p>
<p class="noindent">Before introducing our synchronization algorithm, we remind the reader of a basic subsampling/aliasing property of the Fourier transform, which we introduced in <a href="09_Chapter01.xhtml">Chapter 1</a> and previously used in <a href="12_Chapter03.xhtml">Chapters 3</a>, <a href="14_Chapter05.xhtml">5</a>, and <a href="17_Chapter07.xhtml">7</a>. However, here we will focus <a id="page_112"/>on the dual of this property which states that: <i>Aliasing a signal in the time domain is equivalent to subsampling it in the frequency domain, and vice versa</i>. <a href="#fig8_4">Figure 8.4</a> illustrates this property.</p>
<div class="cap">
<p class="image"><a id="fig8_4"/><img src="../images/fig8_4.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.4</b> The duality of aliasing and subsampling. Aliasing in the time domain corresponds to subsampling in the frequency domain and vice versa. Folding (aliasing) the time domain signal in the top left results in the signal in the top right; specifically, time samples 1 and 6 add into sample 1 in the aliased signal, samples 2 and 7 into sample 2, etc. In the Fourier domain, the FFT of the aliased signal is a subsampled version of the FFT of the initial signal; namely, sample 1 in the bottom right signal corresponds to sample 2 in the bottom left, sample 2 corresponds to sample 4, etc.</p>
</div>
<p class="indent">Formally, let <b>x</b> be a discrete time signal of length n, and <b>X</b> its frequency representation. Let <b>x</b>&#8242; be a version of <b>x</b> in which adjacent windows of size <i>B</i> (where <i>B</i> divides <i>n</i>) are aliased on top of each other (i.e., samples that are <i>p</i> = <i>n/B</i> apart are summed together). Then, for <i>t</i> = 0 &#8230; <i>B</i> &#8211; 1,</p>
<p class="eqn"><a id="eq8_3"/><img src="../images/eq8_3.png" alt="image"/></p>
<p class="noindent">Thus, <b>X</b>&#8242;, the FFT of <b>x</b>&#8242; is a subsampled version of <b>X</b>, and for <i>f</i> = 0 &#8230; <i>B</i> &#8211; 1</p>
<p class="eqn"><a id="eq8_4"/><img src="../images/eq8_4.png" alt="image"/></p>
<p class="noindent">where <i>p</i> = <i>n/B</i>, and the subscript in <i>X<sub>pf</sub></i> refers to the sample whose index is <i>p</i> &#215; <i>f</i>.</p>
<p class="h2"><a id="page_113"/><a id="ch8_3_3"/><b><span class="big1">8.3.3</span>&#160;&#160;&#160;&#160;The QuickSync Algorithm</b></p>
<p class="noindent">We describe how QuickSync operates on a received GPS signal to synchronize it with an internally generated C/A code. For simplicity, we assume that the input signal neither exhibits a carrier frequency offset nor a Doppler shift; in later sections, we extend the algorithm to deal with these frequency offsets. Furthermore, in this section, we describe the algorithm in the context of synchronizing the GPS receiver with the signal of only one satellite; the algorithm can be easily adapted for synchronizing with multiple satellites.</p>
<p class="indent">The key insight to our algorithm is that the IFFT performed in step 3 of the FFT-based synchronization algorithm is sparse in the time domain, i.e., it has only one spike and, hence, can be performed in sub-linear time. Further, a sub-linear time algorithm for computing the Sparse Inverse Fourier Transform would require a sublinear number of samples as input; thus, there is no need to perform a full <i>n</i> log <i>n</i> FFT on the received GPS signal and obtain all of its <i>n</i> frequency samples. Rather, we only need to compute the frequency samples that will be used to perform the Sparse Inverse Fourier Transform.</p>
<p class="indent">Below, we explain how we exploit these ideas to reduce the complexity of both the IFFT and FFT performed to synchronize the signal with the code. We then put these components together in a complete algorithm.</p>
<p class="h3"><a id="ch8_3_3_1"/><b><span class="big2">8.3.3.1</span>&#160;&#160;&#160;&#160;Sparse Inverse Fourier Transform</b></p>
<p class="noindent">We develop a simple algorithm to efficiently perform the IFFT step of GPS synchronization and quickly identify the spike of the correlation between the received signal and the CDMA code. To do so, our algorithm uses a sub-linear number of samples of the signal.</p>
<p class="indent">The Sparse Inverse Fourier Transform algorithm proceeds as follows. It first subsamples the frequency domain signal of size <i>n</i> by a factor of <i>p</i>. It then computes the IFFT over these <i>n/p</i> frequency samples. Recall that subsampling in the frequency domain is equivalent to aliasing in the time domain. Thus, the output of our IFFT step is an aliased version of the output in the original IFFT step shown in <a href="#fig8_1">Figure 8.1</a>. Aliasing here can be viewed as a form of hashing, where the <i>n</i> original outputs samples (i.e., time shifts) are hashed into <i>n/p</i> buckets. Time shifts which are <i>n/p</i> apart will be summed and hashed together in the same bucket at the output of our IFFT. Since there is only one correlation spike in the output of the IFFT, the magnitude of the bucket it hashes into will be significantly larger than that of other buckets where only noise samples hash to. Hence, the algorithm chooses the bucket with the largest magnitude among the <i>n/p</i> buckets at the output of our IFFT.</p>
<p class="indent"><a id="page_114"/>Out of the <i>p</i> time shifts that aliased (or hashed) into this chosen bucket, only one is the actual correlation spike. To identify the spike among these <i>p</i> candidate shifts, the algorithm correlates the received signal with each of those <i>p</i> shifts of the CDMA code. The shift that produces the maximum correlation is the right spike.</p>
<p class="h3"><a id="ch8_3_3_2"/><b><span class="big2">8.3.3.2</span>&#160;&#160;&#160;&#160;Subsampled FFT</b></p>
<p class="noindent">With the sparse IFFT step in place, the algorithm does not need the whole <i>n</i>-point FFT of the signal. Specifically, all the IFFT requires is a subsampled version of this signal. Thus, rather than taking a full <i>n</i>-point FFT, QuickSync aliases the received signal in the time domain before taking its FFT, as in <a href="#eq8_3">Equation 8.3</a>. (Said differently, QuickSync sums up blocks of size <i>n/p</i> and then computes a smaller FFT of size <i>n/p</i>.) The output of this FFT, expressed in <a href="#eq8_4">Equation 8.4</a>, is exactly the samples we need at the input of the sparse IFFT, described above.</p>
<p class="indent">A subsampled input to the IFFT (as described in <a href="#ch8_3_3_1">Section 8.3.3.1</a>) results in an output spike of smaller magnitude relative to the noise bed. To compensate for this loss, we alias <i>p</i> &#215; <i>n</i> samples instead of <i>n</i> into blocks of size <i>n/p</i> before performing the FFT.</p>
<p class="h3"><a id="ch8_3_3_3"/><b><span class="big2">8.3.3.3</span>&#160;&#160;&#160;&#160;Full Algorithm</b></p>
<p class="noindent">The QuickSync algorithm proceeds in the following steps.</p>
<p class="numlist">1.&#160;&#160;<b>Aliasing.</b> Alias <i>p</i> &#215; <i>n</i> samples of the GPS signal into <i>B</i> = <i>n/p</i> samples as described in <a href="#eq8_3">Equation 8.3</a>, where <img src="../images/in115_1.png" alt="image"/>.</p>
<p class="numlist">2.&#160;&#160;<b>Subsampled FFT.</b> Perform an FFT of size <i>n/p</i> on the aliased time signal. This is effectively equivalent to performing an FFT of size <i>pn</i> and subsampling the output by <i>p</i><sup>2</sup> according to <a href="#eq8_4">Equation 8.4</a>.</p>
<p class="numlist">3.&#160;&#160;<b>Multiplying with the code.</b> Subsample the FFT of the satellite CDMA code of length <i>n</i> by <i>p</i>, and multiply the resulting samples by the <i>n/p</i> samples at the output of step 2, above. Note that the algorithm can precompute the FFT of the CDMA code and store it in the frequency domain.</p>
<p class="numlist">4.&#160;&#160;<b>Sparse Inverse Fourier Transform.</b> Perform an IFFT on the <i>n/p</i> resulting samples. Since the input of this IFFT was subsampled, its output is aliased in the time domain. Specifically, each of the <i>n/p</i> buckets at the output of this stage is effectively the sum of <i>p</i> aliased time samples,<sup><a id="fn7" href="#rfn7">7</a></sup> as described in <a href="#ch8_3_3_1">Section 8.3.3.1</a>.</p>
<p class="numlist"><a id="page_115"/>5.&#160;&#160;<b>Find the unique solution.</b> Find the bucket with the maximum magnitude among the <i>n/p</i> buckets. Then, check the correlation of each of the <i>p</i> possible time shifts which are aliased into this bucket, and pick the shift that gives the maximum correlation. Checking the correlation can be done using only <i>n/p</i> samples, as per Lemma F.3; therefore, it takes a total of <i>p</i> &#215; <i>n/p</i> = <i>n</i> to perform the correlation of the <i>p</i> shifts and pick the one that maximizes the correlation.</p>
<p class="h3"><a id="ch8_3_3_4"/><b><span class="big2">8.3.3.4</span>&#160;&#160;&#160;&#160;Runtime</b></p>
<p class="noindent">The running time of the QuickSync algorithm may be computed as follows. Step 1 performs <i>np</i> additions. Step 2 performs an FFT which takes <i>n/p</i> log(<i>n/p</i>). Step 3 performs <i>n/p</i> multiplications. Step 4 takes <i>n/p</i> log(<i>n/p</i>) to perform the IFFT, and finally Step 5 performs <i>n</i> operations to compute the correlations and find the solution. Thus, the complexity of QuickSync is <i>O</i>(<i>pn</i> + (<i>n/p</i>) log(<i>n/p</i>)). To minimize this complexity, we set <img src="../images/in115_1.png" alt="image"/> which makes the overall running time of QuickSync <img src="../images/in115_2.png" alt="image"/>.</p>
<p class="h3"><a id="ch8_3_3_5"/><b><span class="big2">8.3.3.5</span>&#160;&#160;&#160;&#160;Scaling with the SNR</b></p>
<p class="noindent">If the signal is too weak, GPS receivers repeat the synchronization algorithm on subsequent signal samples and sum up the output to average out the noise [Team 2000]. This approach allows the receiver to scale the computation with the SNR of the signal. The approach can be applied independent of the algorithm; hence, we also adopt it for QuickSync. However, QuickSync operates on blocks of size <i>pn</i> whereas the traditional FFT-based algorithm operates on blocks of size <i>n</i>. Both QuickSync and the traditional FFT-based algorithm compare the magnitude squared of the largest spike to the noise variance in the received signal. If the largest spike&#8217;s squared magnitude exceeds the noise variance by a desired margin, the algorithm terminates the search and declares the time shift corresponding to the largest spike as the correct alignment. Otherwise, the algorithm repeats the same process on the subsequent signal samples, and sums the new output with the previous one. Since the spike corresponding to the correct synchronization is at the same time shift in each run, it becomes more prominent. In contrast, noise spikes are random and hence they tend to average out when combining the output of multiple runs of the synchronization algorithm.</p>
<p class="h3"><a id="ch8_3_3_6"/><b><span class="big2">8.3.3.6</span>&#160;&#160;&#160;&#160;Linear Time Algorithm</b></p>
<p class="noindent">The algorithm described in <a href="#ch8_3_3_3">Section 8.3.3.3</a> above can be made linear-time by modifying Step 1: instead of taking <i>pn</i> samples, we take only <i>n</i> samples and alias them <a id="page_116"/>into <i>n/p</i> buckets, where <i>p</i> = log <i>n</i>. The rest of the steps are unmodified. This reduces the complexity of Step 1 to <i>n</i>, and the total complexity of the algorithm to <i>O</i>(<i>n</i> + (<i>n/p</i>) log(<i>n/p</i>)) = <i>O</i>(<i>n</i>).</p>
<p class="indent">This linear-time algorithm has weaker guarantees than the above super-linear algorithm and may not always work at very low SNRs, as detailed in <a href="#ch8_4">Section 8.4</a>. One can try this algorithm first. If a spike is detected with the required margin, the algorithm terminates. Otherwise, one can fall back to the super-linear algorithm in <a href="#ch8_3_3_3">Section 8.3.3.3</a>.</p>
<p class="h1"><b><a id="ch8_4"/><span class="big">8.4</span>&#160;&#160;&#160;&#160;Theoretical Guarantees</b></p>
<p class="noindent">In this section, we analyze the performance of the baseline and QuickSync algorithms (both the linear and super-linear variants), under natural probabilistic assumptions about the input signal <b>x</b>. In particular, we show that both the baseline and the super-linear QuickSync are correct under the same asymptotic assumptions about the variance of the noise in the signal <b>x</b>. At the same time, the running time of our algorithm is equal to <i>O</i>(<i>pn</i> + (<i>n/p</i>) log (<i>n/p</i>)), where <i>p</i> is the number of blocks used. This improves over the baseline algorithm which has <i>O</i>(<i>n</i> log <i>n</i>) runtime as long as the term <i>pn</i> is smaller than (<i>n/p</i>) log(<i>n/p</i>). In particular, by setting <img src="../images/in115_1.png" alt="image"/>, we achieve the running time of <img src="../images/in115_2.png" alt="image"/>.</p>
<p class="h2"><a id="ch8_4_1"/><b><span class="big1">8.4.1</span>&#160;&#160;&#160;&#160;Assumptions</b></p>
<p class="noindent">Recall that we use <b>c</b> = <i>c</i><sub>0</sub> &#8230; <i>c</i><sub><i>n</i>&#8211;1</sub> to denote the spreading code. We use <b>c</b><sup>(<i>t</i>)</sup> to denote the code <b>c</b> shifted by <i>t</i> = 0 &#8230; <i>n</i> &#8211; 1, i.e., <img src="../images/in116_1.png" alt="image"/>. We have that <b>x</b> = <b>c</b><sup>(<i>t</i>)</sup> + <b>g</b> for some shift <i>t</i>, where <b>g</b> denotes the noise vector. We make the following assumptions.</p>
<p class="numlistt">1.&#160;&#160;The coordinates <i>g</i><sub>0</sub> &#8230; <i>g</i><sub><i>n</i>&#8211;1</sub> of the noise vector <b>g</b> are independent and identically distributed random variables that follow a normal distribution with zero mean and variance <i>&#963;</i>. That is, we assume additive white Gaussian noise (AWGN).</p>
<p class="numlist">2.&#160;&#160;The coordinates <i>c</i><sub>0</sub> &#8230; <i>c</i><sub><i>n</i>&#8211;1</sub> of the spreading code <b>c</b> are independent and identically distributed random variables with values in {&#8211;1,1}, such that Pr[<i>c<sub>i</sub></i> = 1] = Pr[<i>c<sub>i</sub></i> = &#8211;1] = 1/2. This assumption models the fact that the CDMA code, <b>c</b>, is <i>pseudorandom</i>.</p>
<p class="h2"><a id="ch8_4_2"/><b><span class="big1">8.4.2</span>&#160;&#160;&#160;&#160;Combining Multiple Runs</b></p>
<p class="noindent">As described in <a href="#ch8_3_3_5">Section 8.3.3.5</a>, both the baseline and our algorithm can sum the output of multiple runs to average out the noise and increase the probability of identifying the correct spike. The analysis of such multi-run scenario can be derived <a id="page_117"/>directly from a single run. Specifically, say the algorithm runs <i>L</i> times and sum up the outputs of these <i>L</i> runs. This is equivalent to reducing the noise variance to <i>&#963;</i>&#8242; = <i>&#963;/L</i>. Therefore, the <i>L</i>-run scenario can be analyzed by reducing it to the case of a single run, with variance divided by <i>L</i>.</p>
<p class="h2"><a id="ch8_4_3"/><b><span class="big1">8.4.3</span>&#160;&#160;&#160;&#160;Guarantees</b></p>
<p class="noindent">Here, we walk the reader through the guarantees. The proofs of the guarantees can be found in <a href="28_Appendix06.xhtml">Appendix F</a>. We start by stating the sufficient condition for the baseline algorithm to work with probability approaching 1.</p>
<p class="noindentt"><b>Theorem 8.1</b> Assume that <i>&#963;</i> &#8804; <i>c</i>(<i>n</i>)<i>n</i>/ ln <i>n</i> for <i>c</i>(<i>n</i>) = <i>o</i>(1). Then the baseline algorithm is correct with probability 1 &#8211; <i>o</i>(1).</p>
<p class="indentt">The proof is in <a href="28_Appendix06.xhtml#appF_1">Appendix F.1</a>. The above condition is also tight. Specifically, we have the following.</p>
<p class="noindentt"><b>Theorem 8.2</b> There exists a constant <i>c</i> &#62; 0 such that for <i>&#963;</i> &#8805; <i>cn</i>/ ln <i>n</i>, the baseline algorithm is incorrect with probability 1 &#8211; <i>o</i>(1).</p>
<p class="indentt">The proof is in <a href="28_Appendix06.xhtml#appF_2">Appendix F.2</a>. We then proceed with the analysis of the two variants of the QuickSync algorithm. The first statement holds for the super-linear variant, and shows that the algorithm works with probability approaching 1 under the same condition as the baseline algorithm, while being faster.</p>
<p class="noindentt"><b>Theorem 8.3</b> Assume that <i>&#963;</i> &#8804; <i>c</i>(<i>n</i>)<i>n</i>/ln <i>n</i> for <i>c</i>(<i>n</i>) = <i>o</i>(1), and that <i>p</i> = <i>o</i>(<i>n</i><sup>1/6</sup>). Then, the Quick-Sync algorithm that aliases <i>p</i> blocks of size <i>n</i> into <i>n/p</i> buckets is correct with probability 1 &#8211; <i>o</i>(1). The running time of the algorithm is <i>O</i>(<i>pn</i> + (<i>n/p</i>) log(<i>n/p</i>)), which is <img src="../images/in115_2.png" alt="image"/> for <img src="../images/in115_1.png" alt="image"/>. Moreover, the algorithm performs only <i>O</i>(<i>n</i> + (<i>n/p</i>) log(<i>n/p</i>)) multiplications, for any <i>p</i>.</p>
<p class="indentt">Finally, we analyze the linear-time variant of the QuickSync algorithm.</p>
<p class="noindentt"><b>Theorem 8.4</b> Assume that <img src="../images/in117_1.png" alt="image"/> for <i>c</i>(<i>n</i>) = <i>o</i>(1), and that <i>p</i> = <i>o</i>(<i>n</i><sup>1/6</sup>). Then, the QuickSync algorithm that aliases one block of <i>n</i> samples into <i>n/p</i> buckets is correct with probability 1 &#8211; <i>o</i>(1). The running time of the algorithm is <i>O</i>(<i>n</i> + (<i>n/p</i>) log(<i>n/p</i>)), which is <i>O</i>(<i>n</i>) for <i>p</i> &#62; log <i>n</i>.</p>
<p class="indentt">The proof of the above two theorems can be found in <a href="28_Appendix06.xhtml#appF_3">Appendix F.3</a>.</p>
<p class="h1"><b><a id="ch8_5"/><span class="big">8.5</span>&#160;&#160;&#160;&#160;Doppler Shift and Frequency Offset</b></p>
<p class="noindent">GPS satellites orbit the Earth at very high speeds. Consequently, the GPS signal arrives at the receiver with a Doppler shift. This shift is modeled as a frequency <a id="page_118"/>offset <i>f<sub>d</sub></i> which is a function of the relative speed of the satellite (see Goldsmith [2005, chapter 2] for exact calculations). Furthermore, the discrepancy between the RF oscillators of the GPS satellite and the GPS receiver induces a carrier frequency offset &#916;<i>f<sub>c</sub></i>. The total frequency offset &#916;<i>f</i> = <i>f<sub>d</sub></i> + &#916;<i>f<sub>c</sub></i> typically ranges from -10 kHz to 10 kHz [Team 2000] and is modeled as a phase shift in the received samples. Formally, if <b>x</b> and <b>x&#771;</b> are, respectively, the signal without and with a frequency offset then:</p>
<p class="eqn"><a id="eq8_5"/><img src="../images/eq8_5.png" alt="image"/></p>
<p class="noindent">where <i>t</i> is time in seconds.</p>
<p class="indent">Like past synchronization algorithms, QuickSync must search and correct for the frequency offset in the received GPS signal in order for the correlation to spike at the correct code shift. However, since QuickSync processes <i>p</i> &#215; <i>n</i> samples as opposed to <i>n</i> samples in past algorithms (see <a href="#ch8_3">Section 8.3</a>), it needs to deal with larger phase shifts that accumulate over <i>pn</i> samples. In order to overcome this limitation, QuickSync performs a finer grained frequency offset search, which introduces an overhead to the 2D search. This overhead, however, is amortized across all satellites in the GPS signal since correcting for this frequency offset is done on the received signal before it is multiplied by each satellite&#8217;s C/A code. In <a href="#ch8_7_2">Section 8.7.2</a>, we show that despite this overhead, QuickSync still provides a significant reduction in the computational complexity of GPS synchronization. Furthermore, the frequency offset changes slowly (see <a href="#ch8_7_2">Section 8.7.2</a>); hence, the receiver can cache its value from recent GPS readings, and does not need to search for it for every GPS synchronization event.</p>
<p class="h1"><b><a id="ch8_6"/><span class="big">8.6</span>&#160;&#160;&#160;&#160;Testing Environment</b></p>
<p class="h2"><a id="ch8_6_1"/><b><span class="big1">8.6.1</span>&#160;&#160;&#160;&#160;Data Collection</b></p>
<p class="noindent">We test our algorithm on a dataset consisting of 40 GPS signal traces captured from urban and suburban areas in the U.S. and Europe. The traces in the U.S. are collected using the SciGe GN3S Sampler v3 [Electronics 2017] shown in <a href="#fig8_5">Figure 8.5</a>. The GN3S is a form of software radio that collects raw complex GPS signal samples. We set the sampling rate of the GN3S to 4.092 MHz and its carrier frequency to 1575.42 MHz. The traces from Europe are collected using the USRP2 software radio [Ettus Inc. 2017] and the DBSRX2 daughterboard, which operates in the 1575.42 MHz range and is capable of powering up active GPS antennas [Ettus Inc. 2017]. The Europe <a id="page_119"/>traces are collected with a sampling frequency of 4 MHz. We also use a 3V magnetic mount active GPS antenna shown in <a href="#fig8_5">Figure 8.5</a>. These datasets allow us to test the performance of QuickSync in different geographical areas and for different GPS receiver hardware.</p>
<div class="cap">
<p class="image"><a id="fig8_5"/><img src="../images/fig8_5.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.5</b> The SciGe GN3S sampler. The sampler is used to collect raw GPS data. It downconverts the received signal and delivers the I and Q samples to the computer.</p>
</div>
<p class="h2"><a id="ch8_6_2"/><b><span class="big1">8.6.2</span>&#160;&#160;&#160;&#160;Baseline Algorithm</b></p>
<p class="noindent">We compare our algorithm against a baseline that uses the traditional FFT-based synchronization [Van Nee and Coenen 1991]. The baseline algorithm operates on blocks of size <i>n</i>. If a spike is not detected after processing the first block, the algorithm repeats the computation on the next block, i.e., the next set of <i>n</i> samples, and sums up the output of the IFFTs. The algorithm keeps processing more blocks until the magnitude of the peak crosses a certain threshold (as described in <a href="#ch8_7_1">Section 8.7.1</a>). Note that the algorithm must sum up the magnitudes of the output of the IFFTs rather than the actual complex values; otherwise, samples would combine incoherently due to the accumulated phase caused by the Doppler shift (see <a href="#ch8_5">Section 8.5</a>).</p>
<p class="h2"><a id="ch8_6_3"/><b><span class="big1">8.6.3</span>&#160;&#160;&#160;&#160;Implementation</b></p>
<p class="noindent">We implement both QuickSync and the FFT-based algorithm in Matlab and run them on the collected GPS traces. Both algorithms use the FFTW [Frigo and Johnson 2017] implementation internally to compute the Fourier transform (though the baseline computes an <i>n</i>-point transform while QuickSync computes an <i>n/p</i>-point transform).</p>
<p class="h2"><a id="page_120"/><a id="ch8_6_4"/><b><span class="big1">8.6.4</span>&#160;&#160;&#160;&#160;Metrics</b></p>
<p class="noindent">We use two metrics for comparing the algorithms: (1) number of multiplications and (2) number of floating point operations (FLOPs). We mainly focus on the number of real multiplications executed until an algorithm finds the synchronization offset. This metric is particularly important for hardware-based GPS synchronization, where multiplications are significantly more expensive than additions [Rabaey et al. 1996], and serve as standard metric to estimate the complexity of a potential hardware implementation [Cheng and Parhi 2007, Tan et al. 2001].</p>
<p class="indent">Some GPS-enabled devices do not have a full fledged GPS receiver hardware to reduce cost and form factor [Maxim IC 2017]. They use a GPS radio to collect signal samples, but offload the synchronization algorithm to the main CPU of the device, where it is done in software. To evaluate QuickSync&#8217;s performance on software-based GPS receivers, we count the number of FLOPs executed by both QuickSync and the baseline. FLOPs is a standard metric used to evaluate software implementations of algorithms, including FFTW [Frigo and Johnson 2017]. It includes both multiplications and additions.</p>
<p class="indent">We count the FLOPs using OProfile, a standard profiler for Linux systems [OProfile 2017]. We run the code in Matlab R2011b under Ubuntu 11.10 on a 64-bit machine with Intel i7 processor. We run OProfile from within Matlab in order to profile the part of the code executed by each algorithm, and get a more accurate estimate of the number of FLOPs. We program OProfile to log the counter INST_RETIRED (the number of executed floating point operations on the Intel i7 processor [OProfile 2017]).</p>
<p class="h1"><b><a id="ch8_7"/><span class="big">8.7</span>&#160;&#160;&#160;&#160;Results</b></p>
<p class="h2"><a id="ch8_7_1"/><b><span class="big1">8.7.1</span>&#160;&#160;&#160;&#160;Setting the Synchronization Threshold</b></p>
<p class="noindent">As explained in <a href="#ch8_3_3_5">Section 8.3.3.5</a>, both QuickSync and the FFT-based synchronization algorithm check that there is a sufficient margin between the detected maximum spike and the noise level, before accepting the spike as the one that identifies the correct alignment. Specifically, they check that the ratio of the spike&#8217;s magnitude squared to the noise variance exceeds a particular threshold. This threshold defines how large the spike has to be in comparison to the bed of noise to ensure enough confidence that the spike is not due to noise and is indeed due to the code matching. Hence, the threshold is a measure of the SNR of the spike and is not dependent on the data. In particular, if the GPS data is noisy as in an urban area, the algorithm will continue processing more data until the threshold is crossed (as discussed in <a id="page_121"/><a href="#ch8_6">Section 8.6</a>). In contrast, if the GPS data is less noisy as in an open suburban area, the algorithm will terminate early on since the spike will cross the threshold after processing one or two blocks.</p>
<div class="cap">
<p class="image"><a id="fig8_6"/><img src="../images/fig8_6.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.6</b> Probability of error vs. the threshold. The plot shows that the probability of error decreases sharply for both algorithms, and that a threshold of 90 for QuickSync and 100 for the baseline produce a zero error probability.</p>
</div>
<p class="indent">In this section, we aim to verify that there is such a threshold that works for all datasets. Thus, we perform the following experiment. We vary the threshold between a value of 1 and 200, and for each of those values, we run both algorithms on a subset of the GPS traces from both datasets. We define the probability of error as the ratio of runs that output a false positive (i.e., in which the algorithm terminates by returning an invalid shift) to the total number of runs at a given threshold.</p>
<p class="indent"><a href="#fig8_6">Figure 8.6</a> plots the probability of errors vs. the preset threshold. The plot shows that setting the threshold to 90 for QuickSync and 100 for the baseline produces a zero error probability. The baseline has a slightly higher error probability than QuickSync. This is because the baseline takes an <i>n</i>-point IFFT and, hence, has to ensure that none of the <i>n</i> &#8211; 1 noise spikes exceeds the correct spike that corresponds to the proper alignment. In contrast, QuickSync takes an <i>n/p</i>-point IFFT and hence has fewer noise spikes that have to be kept below the threshold.</p>
<p class="indent">The figure also shows that the used metric is stable, for example: (1) the metric is consistent across traces captured from two continents and (2) the probability of error decreases monotonically as the threshold increases. This shows that the threshold is independent of the location of the GPS receiver.</p>
<div class="cap">
<p class="image"><a id="page_122"/><a id="fig8_7"/><img src="../images/fig8_7.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.7</b> Gain of QuickSync over the FFT-based algorithm in number of multiplications. The two curves show the CDFs of the QuickSync&#8217;s gains for the U.S. and Europe datasets. QuickSync achieves a median gain of around 2.2&#215; and a maximum gain of 3.3&#215;.</p>
</div>
<p class="indent">In the experiments that follow, we set the thresholds to 90 and 100 for QuickSync and the baseline, respectively. We also use a different set of traces from those used in testing for this threshold to ensure separation between testing and training.</p>
<p class="h2"><a id="ch8_7_2"/><b><span class="big1">8.7.2</span>&#160;&#160;&#160;&#160;Performance in Terms of Hardware Multiplications</b></p>
<p class="noindent">We start by evaluating the performance gain of QuickSync over FFT-based synchronization in terms of the number of hardware multiplications. We run each of QuickSync and the FFT-based algorithm on both traces collected in U.S. and Europe. We run the experiment 1,000 times; each time taking a different subset of samples from these datasets. We compare the total number of multiplications required by each of the algorithms to synchronize with the signals of satellites present in the GPS traces. <a href="#fig8_7">Figure 8.7</a> shows a cumulative distribution function (CDF) of the gain. The gain is calculated as the number of multiplications needed by the FFT-based algorithm divided by the number of multiplications required by QuickSync. The figure shows that QuickSync always outperforms the FFT-based synchronization on both the U.S. and Europe traces with a median gain of 2.2&#215;. This means that QuickSync can save on average twice the number of hardware multiplications.</p>
<p class="indent">To better understand the performance of QuickSync, we zoom in on the number of multiplications required by each algorithm for each of the satellites. Specifically, each point in the CDFs in <a href="#fig8_7">Figure 8.7</a> corresponds to a full GPS reading with all satellites. However, because different satellites have different Doppler shifts and signal strengths, we expect the gains to vary from one satellite to another. Specifically, for <a id="page_123"/>each of the satellites detected in the Europe traces, and for each GPS reading, we measure the number of multiplications required by both algorithms to perform the synchronization. We repeat this experiment 1,000 times on different subsets of the samples and plot the average results in <a href="#fig8_8">Figure 8.8</a>.</p>
<div class="cap">
<p class="image"><a id="fig8_8"/><img src="../images/fig8_8.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.8</b> Number of multiplications on a per satellite basis for the Europe trace. The gain of QuickSync over the FFT-based algorithm varies among different satellites and ranges between 1.5&#215; and 4&#215;.</p>
</div>
<p class="indent"><a href="#fig8_8">Figure 8.8</a> shows that each of the satellites, on average, requires less multiplications using QuickSync. However, the gains vary considerably among those satellites. For example, satellites 5 and 18 have an average gain of 4&#215; whereas satellites 14 and 15 have an average gain of only 1.5&#215;. Examining the Doppler shifts of these satellites we find that satellites 5 and 18 have Doppler shifts of 6,000 Hz and 1,000 Hz, respectively, while satellites 14 and 15 have Doppler shifts of 600 Hz and 6,800 Hz. This shows that the latter require a finer grain Doppler search as explained in <a href="#ch8_5">Section 8.5</a>. However, because QuickSync is opportunistic, it first attempts to search at courser grain shifts (the same as the baseline), but falls back to finer resolutions when it fails to detect a peak that passes the threshold. Even in such scenarios, however, it consistently outperforms the baseline as the figure shows.</p>
<p class="indent">In many scenarios, the receiver knows the Doppler shift a priori. The reason for this is that the Doppler shift varies only slightly between nearby locations and over a time period of about an hour. In order to test how much the Doppler shift varies, we measure the Doppler shift of satellite signals in the GPS traces captured at different locations within a 2-mile diameter geographical area over a period of <a id="page_124"/>2 hr. For each of those satellites, we calculate the mean and the maximum variation in the Doppler shift of all those signals and record them in <a href="#tab8_1">Table 8.1</a>. The mean change is around 100 Hz and the maximum is 300 Hz. Accordingly, since GPS receivers are duty cycled, whenever the receiver wakes up, it may use the Doppler shift it calculated before going to sleep rather than performing an exhaustive search for it. Alternatively, assisted GPS receivers may download the measured Doppler shift from an adjacent base station [Djuknic and Richton 2001]. In both of these situations, the GPS receiver can significantly reduce the overhead of searching for the right Doppler shift.</p>
<p class="tcaption"><a id="tab8_1"/><b>Table 8.1</b> Variation in the Doppler shift in the U.S. traces<sup><i>a</i></sup></p>
<p class="image"><img src="../images/tab8_1.png" alt="image"/></p>
<p class="tsource">a. For a given satellite, the Doppler shift of the received signal varies very little over a period of 2 hr and in an area of 2-mile diameter.</p>
<p class="indentt">In order to measure the gains of QuickSync without the Doppler search, we repeat the first experiment but this time by providing each of the synchronization algorithms with the correct Doppler shift for each satellite. <a href="#fig8_9">Figure 8.9</a> shows a CDF of QuickSync&#8217;s gain over the FFT-based algorithm in terms of number of multiplications over all the runs on both traces. For both traces, QuickSync achieves a median gain of 4.8&#215;. This shows that QuickSync&#8217;s gains increase when the receiver caches the correct Doppler shift across readings. We note that some of the traces benefit from QuickSync much more than others; the reason is that these runs have higher SNRs such that QuickSync can synchronize to their signals using the linear-time algorithm without falling back to the super-linear variant.</p>
<p class="h2"><a id="ch8_7_3"/><b><span class="big1">8.7.3</span>&#160;&#160;&#160;&#160;Performance on Software-Based GPS Receivers</b></p>
<p class="noindent">In this section, we test the performance of QuickSync on software-based GPS receivers in terms of the number of floating point operations (FLOPs). We run QuickSync and the FFT-based algorithm on the U.S. and Europe traces and use OProfile to count the number of FLOPs as described in <a href="#ch8_6">Section 8.6</a>. We run the experiment 1,000 times with a different subset samples of the traces and calculate the gain as the ratio of the number of FLOPs required by the FFT-based algorithm to the number of FLOPs required by QuickSync. We do not assume in this experiment that <a id="page_125"/>the Doppler shift is known and we let both algorithms search for the right Doppler shift. <a href="#fig8_10">Figure 8.10</a> shows a CDF of the gains. QuickSync achieves a median gain of 2&#215; and 2.3&#215; over the FFT-based algorithm for the U.S. and Europe traces, respectively. This shows that QuickSync can reduce the number of CPU computation on average by half in software-based GPS receivers.</p>
<div class="cap">
<p class="image"><a id="fig8_9"/><img src="../images/fig8_9.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.9</b> Gain of QuickSync over the FFT-based algorithm when the Doppler shift is known. The two curves show the CDFs of the gain in number of multiplications for both of our GPS traces. QuickSync achieves a median gain of 4.8&#215;.</p>
</div>
<div class="cap">
<p class="image"><a id="fig8_10"/><img src="../images/fig8_10.png" alt="image"/></p>
<p class="figcaption"><b>Figure 8.10</b> Gain of QuickSync over the FFT-based algorithm in FLOPs. This metric illustrates the gains of QuickSync for a software-based implementation. The CDFs show a median gain of about 2.2&#215; and a maximum gain of around 3.7&#215;.</p>
</div>
<p class="h1"><a id="page_126"/><b><a id="ch8_8"/><span class="big">8.8</span>&#160;&#160;&#160;&#160;Related Work</b></p>
<p class="noindent">FFT-based GPS synchronization was first proposed by Van Nee and Coenen [1991], who showed that it reduces synchronization complexity from <i>O</i>(<i>n</i><sup>2</sup>) to <i>O</i>(<i>nlog</i>(<i>n</i>)), where <i>n</i> is the number of samples per C/A code. QuickSync builds on this technique and leverages the Sparse Fourier Transform to further reduce the synchronization complexity.</p>
<p class="indent">Our approach is related to past work on GPS block-averaging [Team 2000, Mohamed Sahmoudi and Amin 2008], which sums up consecutive signal blocks before performing the FFT. QuickSync however differs from that work along two axes. First, on the algorithmic front, past work performs a full size FFT of <i>n</i> points. One cannot simply replace this <i>n</i>-point FFT with the Sparse Inverse Fourier Transform because, as explained in <a href="#ch8_1">Section 8.1</a>, the output of the FFT is not sparse. In contrast, QuickSync introduces a design that can harness the Sparse Fourier Transform. This enables QuickSync to operate with a smaller FFT of size <i>n/p</i>, which provides faster synchronization. Second, past work on block-averaging focuses on weak GPS signals and does not provide an adaptive design that works for the whole range of GPS SNRs. Applying their approach to the whole SNR range can incur unnecessary overhead. This is because they average and pre-process many blocks independent of the SNR. As a result, these schemes increase the synchronization delay for scenarios in which only one (or a few) blocks are sufficient for detecting the spike. In contrast, our algorithm adaptively processes more data when the spike is too low for detection, and hence gracefully scales with the SNR of the received GPS signal.</p>
<p class="indent">Signal synchronization is a general problem that applies to other wireless technologies, e.g., WiFi and cellular. However, synchronization in these technologies is simpler because the noise level in the received signals is much lower than in GPS. For example, WiFi receivers can lock on the signal simply by detecting an increase in the received power [Heiskala and Terry 2001]. This is not possible in GPS since the signal is received at 20 dB <i>below</i> the noise floor [Plausinaitis 2017]. Cellular systems also operate at much higher SNRs than GPS, which allows them to synchronize with relatively low overhead [Karim and Sarraf 2002].</p>
<p class="indent">QuickSync is also related to the general class of work on reducing GPS power consumption. The most common approach uses assisted-GPS [Jani Jarvinen and DeSalas 2002, Ramos et al. 2011], which involves connecting to an assisted GPS server through a WiFi or cellular network. The server provides the GPS receiver with the GPS data decoded from each satellite signal, which allows the receiver to avoid decoding the GPS signal. The device can also offload GPS computations to the cloud after acquiring the GPS signal [Nirjon et al. 2014, Liu et al. 2014, Fleishman <a id="page_127"/>2011]. The latter approach, however, reduces the complexity of the device but still requires the device to transmit the GPS signal to the cellular tower (thus consuming transmission power and even bandwidth [Fleishman 2011]). Other approaches for reducing GPS power consumption leverage WiFi, sensors, or the cellular signal to localize the receiver [Bulusu et al. 2000, Niculescu and Nath 2001, Thiagarajan et al. 2011]. These schemes typically are less accurate than GPS and are more constrained in terms of where they can be deployed. Our work contributes to this effort by tackling the complexity of the GPS receiver itself.</p>
<p class="h1"><b><a id="ch8_9"/><span class="big">8.9</span>&#160;&#160;&#160;&#160;Conclusion</b></p>
<p class="noindent">This chapter presents the fastest synchronization algorithm for GPS receivers to date. The gains of the algorithm are also empirically demonstrated for software GPS implementations as well as potential hardware architectures. Because synchronization consumes a significant amount of power, we expect the reduced complexity to decrease GPS power consumption. Further, we believe that the sparse synchronization algorithm we introduced has other applications in signal processing and pattern matching. We plan to explore those applications in future work.</p>
<p class="line"/>
<p class="foot"><a id="rfn1" href="#fn1">1</a>. The data includes almanac, ephemeris, and reference time. AGPS may also provide other optional assistance data [Jani Jarvinen and DeSalas 2002].</p>
<p class="foot"><a id="rfn2" href="#fn2">2</a>. The CDMA code consists of 1,023 chips (code bits) transmitted at 1.023 MHz. For a GPS receiver that samples at 5 MHz, the computational complexity of the shifted correlation is (1,023 &#215; 5/1.023)<sup>2</sup>, which is about 25 million multiplications of complex signal samples. The GPS receiver has to repeat this process for multiple satellites (between 4&#8211;12 satellites) and multiple Doppler shifts (between 21&#8211;41 shifts) for each satellite, which brings the number of multiplications to over a billion. Further, correlating with one block of the signal may not be sufficient. For weak signals, the receiver may need to repeat this process and sum up the output [Kaplan 1996].</p>
<p class="foot"><a id="rfn3" href="#fn3">3</a>. Sparse Fourier Transform algorithms are designed for the case where the output of the Fourier Transform contains only a small number of spikes. Hence, they are applicable to both Sparse Fourier Transform and Sparse Inverse Fourier Transform. For a more detailed description, see <a href="#ch8_3">Section 8.3</a>.</p>
<p class="foot"><a id="rfn4" href="#fn4">4</a>. Note that <i>n</i> is not a constant and varies across GPS receivers. Specifically, different receivers sample the GPS signal at different rates, hence obtaining a different number of samples per codeword. For example, for a receiver whose sampling rate is 5 MHz, <i>n</i> = 5,000, whereas for a 4 MHz receiver, <i>n</i> = 4,000.</p>
<p class="foot"><a id="rfn5" href="#fn5">5</a>. The Europe dataset is courtesy of the GNSS-SDR team [Fernandez-Prades et al. 2011] at the Centre Tecnologic de Telecomunicacions de Catalunya (CTTC).</p>
<p class="foot"><a id="rfn6" href="#fn6">6</a>. All GPS satellites use atomic clocks and are fully synchronized with one another [Kaplan 1996]. Hence, a GPS receiver will have the same clock skew with respect to all satellites and all the estimated propagation delays will have the same error <i>&#8714;</i>. However, trilateration needs only four satellites to estimate the position and thus extra satellites can be used to estimate and correct <i>&#8714;</i>.</p>
<p class="foot"><a id="rfn7" href="#fn7">7</a>. Note that we only get <i>p</i> candidate shifts (and not <i>p</i><sup>2</sup>) because the actual code is of size n; hence, all shifts mod n are the same. Thus, although the total number of samples is <i>np</i> and they are aliased into <i>n/p</i> buckets, we only have <i>p</i> distinct shifts per bucket.</p>
</body>
</html>
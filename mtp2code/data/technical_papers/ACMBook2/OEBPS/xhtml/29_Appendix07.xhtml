<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Sparse Fourier Transform: Theory and Practice</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="../styles/page-template.xpgt"/>
</head>
<body>
<p class="chnoa"><a id="page_241"/><b>APPENDIX</b></p>
<p class="chno"><b>G</b></p>
<p class="chtitle"><b>A 0.75 Million Point Sparse Fourier Transform Chip</b></p>
<p class="noindent">In this appendix, we present the first VLSI implementation of the Sparse Fourier Transform algorithm. The chip implements a 746,496-point Sparse Fourier Transform, in 0.6 mm<sup>2</sup> of silicon area. At 0.66V, it consumes 0.4 pJ/sample and has an effective throughput of 36 GS/s. The effective throughput is computed over all frequencies but frequencies with negligible magnitudes are not produced. The chip works for signals that occupy up to 0.1% of the transform frequency range (0.1% sparse). It can be used to detect a signal that is frequency hopping in a wideband, to perform pattern matching against a long code, or to detect a blocker location with very high frequency resolution. For example, it can detect and recover a signal that occupies 18 MHz randomly scattered anywhere in an 18 GHz band with a frequency resolution of &#8776; 24 kHz.</p>
<p class="h1a"><a id="appG_1"/><span class="big">G.1</span>&#160;&#160;&#160;&#160;The Algorithm</p>
<p class="noindent">We start by describing the Sparse Fourier Transform algorithm implemented on this chip. Below are bucketization, estimation, and collision resolution techniques we used for our implementation.</p>
<p class="hang"><b>Bucketization.</b> The algorithm starts by mapping the spectrum into buckets. This is done by subsampling the signal and then performing an FFT. Subsampling in time causes aliasing in frequency. Since the spectrum is sparsely occupied, most buckets will be either empty or have a single active frequency, and only few buckets will have a collision of multiple active frequencies. Empty buckets are discarded and non-empty buckets are passed to the estimation step.</p>
<p class="hang"><b>Estimation.</b> This step estimates the value and frequency number (i.e., location in the spectrum) of each active frequency. In the absence of a collision, the <a id="page_242"/>value of an active frequency is the value of its bucket. To find the frequency number, the algorithm repeats the bucketization on the original signal after shifting it by 1 sample. A shift in time causes a phase change in the frequency domain of 2<i>&#960;f &#964;/N</i>, where <i>f</i> is the frequency number, <i>&#964;</i> is the time shift, and <i>N</i> is the Sparse Fourier Transform size. Thus, the phase change can be used to compute the frequency number.</p>
<p class="hang"><b>Collision Resolution.</b> The algorithm detects collisions as follows: If a bucket contains a collision then repeating the bucketization with a time shift causes the bucket&#8217;s magnitude to change since the colliding frequencies rotate by different phases. In contrast, the magnitude does not change if the bucket has a single active frequency. After detecting collisions, the algorithm resolves them by using bucketization multiple times with co-prime sampling rates (FFTs with co-prime sizes). The use of co-prime sampling rates guarantees that any two frequencies that collide in one bucketization do not collide in other bucketizations.</p>
<p class="h1a"><a id="appG_2"/><span class="big">G.2</span>&#160;&#160;&#160;&#160;The Architecture</p>
<p class="noindent">The block diagram of the Sparse Fourier Transform chip is shown in <a href="#figG_1">Figure G.1</a>. A 12-bit 746,496-point (2<sup>10</sup> &#215; 3<sup>6</sup>-point) Sparse Fourier Transform is implemented. Two types of FFTs (2<sup>10</sup> and 3<sup>6</sup>-point) are used for bucketization. The input to the 2<sup>10</sup>-point FFT is the signal subsampled by 3<sup>6</sup>, while the input to the 3<sup>6</sup>-point FFT is the signal subsampled by 2<sup>10</sup>. FFTs of sizes 2<sup>10</sup> and 3<sup>6</sup> were chosen since they are co-prime and can be implemented with simple low-radix FFTs. Three FFTs of each size are used with inputs shifted by 0, 1, or 32 time samples, as shown in <a href="#figG_1">Figure G.1</a>. In principle, shifts of 0 and 1 are sufficient. However, the third shift is used to increase the estimation accuracy. One 1024-word and one 729-word SRAMs are used for three 2<sup>10</sup>-point and three 3<sup>6</sup>-point FFTs, respectively. SRAMs are triplicated to enable pipelined operation of the I/O interface, bucketization, and reconstruction blocks. Thus, three Sparse Fourier Transform frames exist in the pipeline.</p>
<p class="indent">The micro-architecture of the 2<sup>10</sup>-point FFT is shown in <a href="#figG_2">Figure G.2</a>. Each 2<sup>10</sup>-point FFT uses one radix-4 butterfly to perform an in-place FFT, which is optimized to reduce area and power consumption as follows. First, the FFT block performs read and write operations at even and odd clock cycles, respectively, which enables the use of single port SRAMs. A single read operation provides three complex values, one for each radix-4 butterfly. The complex multiplication is computed over two clock cycles using two multipliers for each butterfly. Second, a twiddle factor (TWF) control unit is shared between the three butterflies. Third, the block floating point (BFP) technique is used to minimize the quantization error [Zhong et al. 2006]. BFP is implemented using a single exponent shared between FFTs, and scaling is done by shifting in case of overflow. Round-half-away-from-zero is implemented by initializing the accumulator registers with 0.5 LSB and truncating the results. The 3<sup>6</sup>-point FFTs are similar, but use radix-3 butterflies.</p>
<div class="cap">
<p class="image"><a id="page_243"/><a id="figG_1"/><img src="../images/figG_1.png" alt="image"/></p>
<p class="figcaption"><b>Figure G.1</b> A block diagram of the 2<sup>10</sup> &#215; 3<sup>6</sup>-point Sparse Fourier Transform. The I/O interface, bucketization, and reconstruction blocks operate in parallel on three different Sparse Fourier Transform frames. The figure also shows the input samples to the six FFTs.</p>
</div>
<p class="indent">The micro-architecture of estimation and collision detection is shown in <a href="#figG_3">Figure G.3</a>. Phase shift and phase detector units use the CORDIC algorithm. The estimation block operates in two steps. First, time shifts of 1 and 32 samples are used to compute the MSBs and LSBs of the phase change, respectively. A 3-bit overlap is used to fix errors due to concatenation. Since the 5 MSBs of phase change are taken directly from the output of phase detectors, active frequencies have to be <i>&#8776;</i> 30dB above the quantization noise to be detected correctly. Frequencies below this level are considered negligible. The frequency number is estimated from the phase change. This frequency number may have errors in the LSBs due to quantization noise. The second step corrects any such errors by using the bucket number to recover the LSBs of the frequency number. This is possible because all frequencies in a bucket share the same remainder <i>B</i> (<i>B = f</i> mod <i>M</i>, where <i>f</i> is the frequency number and <i>M</i> is the FFT size), which is also the bucket number. Thus, in the frequency recovery block associated with the 2<sup>10</sup>-point FFTs, the bucket number gives the 10 LSBs of the frequency number. However, in the frequency recovery for the 3<sup>6</sup>-point FFTs, the LSBs cannot be directly replaced by the bucket number since <i>M</i> = 3<sup>6</sup> is not a power of 2. Instead, the remainder of dividing the frequency number by 3<sup>6</sup> is calculated and subtracted from the frequency number. The bucket number is then added to the result of the subtraction. In our implementation, calculating and subtracting the remainder is done indirectly by truncating the LSBs of the phase change.</p>
<div class="cap">
<p class="image"><a id="page_244"/><a id="figG_2"/><img src="../images/figG_2.png" alt="image"/></p>
<p class="figcaption"><b>Figure G.2</b> The micro-architecture of the 2<sup>10</sup>-point FFTs. Block floating point (BFP) is used to reduce the bit-width requirement during the computation of the FFT, while maintaining the required resolution at the output.</p>
</div>
<div class="cap">
<p class="image"><a id="page_245"/><a id="figG_3"/><img src="../images/figG_3.png" alt="image"/></p>
<p class="figcaption"><b>Figure G.3</b> The micro-architecture of collision detection, estimation, and frequency recovery. The complex values (<i>r</i><sub>1</sub>, <i>i</i><sub>1</sub>) (<i>r</i><sub>2</sub>, <i>i</i><sub>2</sub>), and (<i>r</i><sub>3</sub>, <i>i</i><sub>3</sub>) are the output of bucketization for time-shifts 0,1, and 32 samples. In frequency recovery, three bits of overlap are used to fix errors due to concatenation (<i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>).</p>
</div>
<p class="indent">The collision detection block in <a href="#figG_3">Figure G.3</a> compares the values of the buckets with and without time-shifts. It uses the estimated frequency to remove the phase change in the time-shifted bucketizations and compares the three complex values to detect collisions. In the case of no collision, the three values are averaged to reduce noise. The result is used to update the output of the Sparse Fourier Transform in SRAMs.</p>
<p class="tcaption"><a id="page_246"/><a id="tabG_1"/><b>Table G.1</b> Sparse Fourier transform chip features</p>
<p class="image"><img src="../images/tabG_1.png" alt="image"/></p>
<p class="h1a"><a id="appG_3"/><span class="big">G.3</span>&#160;&#160;&#160;&#160;The Chip</p>
<p class="noindent">The testchip is fabricated in IBM&#8217;s 45 nm SOI technology. <a href="#tabG_1">Table G.1</a> shows the features of the Sparse Fourier Transform chip and <a href="#figG_4">Figure G.4</a> shows the die photo of the testchip. The Sparse Fourier Transform core occupies 0.6 mm<sup>2</sup> including SRAMs. At 1.18 V supply, the chip operates at a maximum frequency of 1.5 GHz, resulting in an effective throughput of 109 GS/s. At this frequency, the measured energy efficiency is 1.2 <i>&#956;</i>J per 746,496-point Fourier transform. Reducing the clock frequency to 500 MHz enables an energy efficiency of 298 nJ per Fourier transform at 0.66 V supply. Energy and operating frequency for a range of supply voltages are shown in <a href="#figG_5">Figure G.5</a>.</p>
<p class="indent">Since no prior ASIC implementations of the Sparse Fourier Transform exist, we compare with recent low power implementations of the traditional FFT [Seok et al. 2011, Chen et al. 2008, Yang et al. 2012]. The measured energy is normalized by the Fourier transform size to obtain the energy per sample (the Sparse Fourier Transform chip, however, outputs only active frequencies). <a href="#tabG_2">Table G.2</a> shows that the implementations in Seok et al. [2011], Chen et al. [2008], and Yang et al. [2012] work for sparse and non-sparse signals while the Sparse Fourier Transform chip works for signal sparsity up to 0.1%. However, for such sparse signals, the chip delivers &#8776; 40&#215; lower energy per sample for a 36&#215; larger FFT size. Finally, the 746,496-point Sparse Fourier Transform chip runs in 6.8 when <i>&#956;</i>s operated at 1.5 GHz which corresponds to an 88 &#215; reduction in runtime compared to the C++ implementation that takes 600 <i>&#956;</i>s on an Intel-Core i7 CPU operating at 3.4 GHz.</p>
<div class="cap">
<p class="image"><a id="page_247"/><a id="figG_4"/><img src="../images/figG_4.png" alt="image"/></p>
<p class="figcaption"><b>Figure G.4</b> Die photo of the Sparse Fourier Transform chip.</p>
</div>
<div class="cap">
<p class="image"><a id="page_248"/><a id="figG_5"/><img src="../images/figG_5.png" alt="image"/></p>
<p class="figcaption"><b>Figure G.5</b> Chip measurement results. Energy and frequency of operation for a range of voltage, and throughput vs. Energy per sample for computing a 2<sup>10</sup> &#215; 3<sup>6</sup>-point Sparse Fourier Transform.</p>
</div>
<p class="tcaption"><a id="tabG_2"/><b>Table G.2</b> Comparison of Sparse Fourier Transform chip with FFT chips<sup><i>a</i></sup></p>
<p class="image"><img src="../images/tabG_2.png" alt="image"/></p>
<p class="source">a. The measured energy efficiency and performance of the Sparse Fourier Transform chip compared to published FFTs. For applications with frequency-sparse signals, the Sparse Fourier Transform enables 43 &#215; lower energy per sample.</p>
</body>
</html>